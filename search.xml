<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实用算法总结(二) 栈和队列]]></title>
    <url>%2F2019%2F01%2F02%2F%E5%AE%9E%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93(%E4%BA%8C)%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈线性表：有限个数据元素组成的序列，记作(a1,a2, … , an) 栈：操作受限的特殊线性表，即限定在表尾进行插入或删除操作的线性表； 栈顶(top)：允许插入或删除的一端——表尾端； 栈底（base/bottom）——表头端 特性：后进先出 存储结构： &emsp;顺序栈：顺序方式存储 &emsp;链栈：链式存储 栈的应用举例：函数调用； 顺序栈的定义与实现顺序栈：利用顺序表来实现栈 C语言定义： 12345678struct stack_struct &#123; ElemType *base; /* point to base of stack */ int stack_size; /* number of elements */ int min_stack; /* bottom-most element */ int max_stack; /* last possible element */ int top; /* current top */&#125;;typedef struct stack_struct Stack; 原子操作的实现：Stack *this_stack; 创建空栈（初始化栈） &emsp;将this_stack-&gt;base指向分配成功的连续内存空间的开始处; &emsp;this_stack-&gt;top=-1（注意不是0,若为0则意味着栈中已有一个元素了）; 销毁已有栈 123//关键操作this_stack-&gt;top=-1;free(this_stack-&gt;base); 查找直接后继和直接前驱 &emsp;若要查看的元素下标是合法的（[0,top]），则可以通过this_stack-&gt;base的下标来随机存取与栈顶元素间隔为i的栈元素 ： 1( this_stack-&gt;base )[this_stack-&gt;top – i]. 入栈 &emsp;若栈未满，则让栈顶下标top递增，然后将要入栈的数复制到栈顶处。 &emsp;分析：插入位置为栈顶元素的下一个，无须判断位置的合法性；上溢即栈满的条件需要判断，由于是增量式分配，故栈满时需要重新申请空间. 出栈 &emsp;若栈未空，则将栈顶元素复制到一个指定的目的地；并让栈顶下标top递减以指向栈上的下一个元素：1this_stack-&gt;top -= 1 入栈和出栈的时间复杂度都是O(1) 关键问题：怎么判断栈满、栈空？ 栈空: stack-&gt;top==-1 栈满：stack-&gt;top == this_stack-&gt;max_stack 链栈的定义与实现链栈：用链表来实现栈 栈顶(top)：用链表的头指针来表示。 栈底(base)：无需额外表示。(只在栈顶top中进行操作) 特点：无栈满问题，内存可以扩充，除非是内存不足。 链栈的原子操作课件中没有涉及，个人觉得也应该掌握，参考了一下博客：数据结构 第6讲 链栈，总结如下： 定义链栈 12345typedef struct Snode&#123; ElemType data; struct Snode *next;&#125;Snode,*LinkStack； 初始化链栈 12345bool InitStack(LinkStack &amp;S) //构造一个空栈S&#123; S=NULL; return true;&#125; 入栈 123456789bool Push(LinkStack &amp;S, int e) //在栈顶插入元素e&#123; LinkStack p; p = new Snode; //生成新结点 p-&gt;data = e; //将e放在新结点数据域 p-&gt;next = S; //将新结点的指针域指向S，即将S的地址赋值给新结点的指针域 S = p; //修改栈顶指针为p return true;&#125; 出栈 123456789101112bool Pop(LinkStack &amp;S, int &amp;e) //删除S的栈顶元素，用e保存其值&#123; LinkStack p; if (S == NULL) //栈空 return false; e = S-&gt;data; //将栈顶元素赋给e p = S; //用p保存栈顶元素地址，以备释放 S = S-&gt;next; //修改栈顶指针，指向下一个结点 delete p; //释放原栈顶元素的空间 return true;&#125; 取栈顶元素 123456int GetTop(LinkStack S) //返回S的栈顶元素，不修改栈顶指针&#123; if (S != NULL) //栈非空 return S-&gt;data; //返回栈顶元素的值，栈顶指针不变 else return -1;&#125; 问题： 1.需要引入头结点（无需） 2.在链栈下的入栈、出栈如何实现？(见上面) 3.如何判断栈空？（头指针为空即栈空） 4.顺序栈中为何要定义base（个人觉得是用来检查内存分配是否成功，以及访问栈中的元素也要借助base) 两种栈的总结对比推荐使用顺序栈，实现简单 栈的受限操作的特性正好屏蔽了顺序表的弱势：添加和删除数据都是在同一端进行的。 栈的应用:递归这里知识其实挺多的，在此简单总结一下： 递归的实现： 调用前： &emsp;现场保护（参数、返回地址、旧基址），被调用函数的局部变量的空间分配，控制转移至被调用的函数入口。 调用后： &emsp;保存计算结果，释放被调函数的数据区，控制转移回调用处。 实现——栈 “后调用先返回”。系统利用递归工作栈记录各层调用的现场信息。 补充：C中进程的虚拟内存分配 1、栈区（stack）： &emsp;由编译器自动分配和释放，存放函数的参数值、局部变量的值等，甚至函数的调用过程都是用栈来完成。其操作方式类似于数据结构中的栈。 2、堆区（heap）： &emsp;一般由程序员手动申请以及释放，若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。 3、全局区（静态区）（static）： &emsp;全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放空间。 4、文字常量区： &emsp;常量字符串就是放在这里的。程序结束后由系统释放空间。 5、程序代码区：存放函数体的二进制代码。 总结：什么时候可以使用栈？ 程序员需要跟踪程序当前所在的位置 程序员需要知道什么动作或数据位于当前正在进行的动作之前 队列队列：是操作受限的特殊线性表。限定在一端进行插入，而在另一端进行删除。 队头(front)：允许删除的一端； 队尾(rear)：允许插入的一端 特性：先进先出 存储结构： 循环队列：顺序存储 链队列：链式存储 队列的应用举例：操作系统的作业排队； 顺序队列定义：利用顺序表来实现队列。约定front指向队列头元素，rear 指向队尾元素的下一位置。 C语言定义：1234567#define MAXQSIZE 100 /* 最大队列长度 */typedef struct&#123;ElemType *base; /* 存储空间 */int front; /* 头指针，指向队列的头元素 */int rear; /* 尾指针，指向队尾元素的下一个位置 */&#125; queue_struct; /* 非增量式的空间分配 */ typedef struct SqQueue; 原子操作：SqQueue Q; 创建空队列 &emsp;将this_stack-&gt;base指向分配成功的连续内存空间的开始处; Q.front=Q.rear=0; 入队 &emsp;若队列未满， Q.rear位置放新插入的元素，Q.rear++（可避免大量移动） （分析：插入位置为Q.rear，无须判断位置的合法性；上溢即队列满的条件需要判断，由于是增量式分配，故队列满时需要重新申请空间）; 出队 &emsp;若队列未空，则Q.front位置为待删除的元素，Q.front++（可避免大量移动） 问题： 1）如何判定队空？如何判定队满？ 队空条件：Q.front == Q.rear 队满条件：Q.rear == MAXQSIZE 2）为何要使用循环队列，而不用普通的顺序式队列？ 存在假上溢(由于出队操作，队列空间的上部可能存在空闲空间) 循环队列解决假上溢的方法：将队列假想为首尾相接的环，即循环队列。 入队：Q.rear = ( Q.rear+1)%MAXQSIZE 出队：Q.front = ( Q.front+1)%MAXQSIZE 队空条件：Q.front ==Q.rear，由于出队Q.front追上了Q.rear 队满条件：Q.front == Q.rear，由于入队Q.rear追上了Q.front 问题：队空和队满的判断条件一样 如何区分队空和队满？ 方案1：设标志位：不足在于需要额外对标志位的判断及维护 方案2：在队列的结构中引入长度成员，在初始化队列、入队、出队操作中维护这个成员。 方案3：少用一个元素空间，即队满的条件如下： (Q.rear+1)% MAXQSIZE == Q.front 链队列链队列：用双向链表来实现队列。 队头(front)：用链表的头指针来表示； 队尾(rear)：用链表的尾指针来表示 特点：无队列满问题：内存可扩充（除非是内存不足）； 问题： 1）是否需引入头结点？（需要。特殊：对于空队列的入队） 空队列时候，队头front和队尾rear都指向头结点。 2）在链队列下的队列初始化、入队、出队算法如何实现？ （略,后续有时间再补充） 3）如何判断队空？ Q.front==Q.rear 队列的总结循环队列：（难）需额外区分队空和队满 链队列：（推荐）（直接利用带头结点的双向链表来实现） 参考资料【1】中科大余艳玮老师实用算法课程 【2】[程序员实用算法].Andrew.Binstock.等著 【3】数据结构 第6讲 链栈]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习总结（一）]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[机器学习期末总结~知识的搬运和总结，大部分内容来源于张曙老师机器学习课程~ 第一章 绪论1.1 机器学习的历史（略） 1.2 什么是机器学习对于给定的任务T，在合理的性能度量方案P的前提下，某计算机程序可以自主学习任务T的经验E，随着提供合适、优质、大量的经验E，该程序对于任务T的性能逐步提高。 所谓机器学习更通俗的说就是：我们使用计算机设计一个系统，使它能够根据提供的训练数据按照一定的方式来学习，随着训练次数的增加，该系统可以在性能上不断学习和改进，通过参数优化的学习模型，能够用于预测相关问题的输出。 1.3 基本概念 有监督学习(Supervised Learning)： &emsp;根据已有的训练样本，通过不断计算，从样本中学习选择特征参数，对模型建立目标函数，从而对未知样本进行预测。 &emsp;优点：可以有效利用先验数据对后验数据进行预测 &emsp;缺点：训练数据人为收集，具有一定的主观性，预测结果只可能是训练数据中的类别，不会产生出新的类别。&emsp;如神经网络、SVM、决策树等。 无监督学习(Unsupervised Learning)： &emsp;对模型不事先进行先验知识学习，不对模型进行训练，使用未分类的样本数据直接进行分类的过程。 &emsp;优点：人为干预较少，结果具有一定的客观性。 &emsp;缺点：计算过程较为复杂。如聚类算法等。 输入与输出空间 &emsp;输入与输出所有可能取值的集合分别称为输入空间X和输出空间Y。输入空间和输出空间可以是有限集合，也可以是整个欧氏空间； &emsp;输入与输出空间可以是同一空间，也可以是不同空间。但通常输出空间远小于输入空间。 训练集(training set) &emsp;从数据中学习得到模型的过程称为“学习”或“训练”，训练过程中使用的数据称为“训练样本”。训练样本由输入和输出对组成，所有的训练样本对构成了训练集，表示为：&emsp;T={(x1,y1),(x2,y2),…,(xm,ym)} 假设空间Н(hypothesis space) &emsp;学习的目的就是要找到一个由输入到输出映射（假设）最好的模型，由输入空间到输出空间所有映射的集合称为假设空间。 &emsp;即：我们可以把学习过程看作为一个在所有假设组成的空间中进行搜索的过程，搜索目标是找到与训练集匹配的假设。 奥卡姆剃刀(Occam’s razor)原则 &emsp;奥卡姆剃刀原则是自然科学研究中一种常用和最基本的原则，即“若有多个假设与观察一致，则选用最简单的那个”。 回归(regression)和分类(classification) &emsp;回归和分类是对不同预测任务的相应称法。 &emsp;若我们要预测（输出）的结果是连续值，则此类学习任务称为回归； &emsp;若我们要预测（输出）的结果是离散值，则此类学习任务称为分类。 &emsp;若问题输出结果只有二个类别，则通常称为二分类问题，否则为多分类问题。 &emsp;回归包含线性回归和逻辑回归，线性回归等同于函数拟合，用于模型学习和连续值输出；逻辑回归可解决分类问题，输出离散值。 1.4 常用评价指标 错误率E &emsp;输出错误的样本数占样本总数的比例 &emsp;E=α/m &emsp;其中α为错分数，m为样本总数 正确率或称准确率 &emsp;Acc=1-E 误差(error) &emsp;模型预测输出与样本真实输出之间的差异称为误差 经验(训练)误差 &emsp;模型在训练集上的误差称为经验或训练误差。 泛化误差(generalization error) &emsp;模型在新样本上的误差称为泛化误差。所谓泛化是指从特殊到一般的过程，即从具体事实归纳出一般规律的过程。 方差和均方差 &emsp;方差又称均方误差是误差分析中比较常用的一种指标，其定义为： &emsp;在预测任务中，对于给定的数据集T={(x1,y1),(x2,y2),…,(xm,ym)}，f(x)为模型预测输出，y为样本真实输出，则二者之间的方差为： &emsp;对于连续域的情况： &emsp;其中p(x)为概率密度函数 &emsp;均方差(标准差)： 过拟合(over-fitting) &emsp;过拟合是指学习时选择模型所包含的参数过多，以至于出现模型对已知数据预测的很好，对未知数据预测得很差的现象。和过拟合相对应的现象为欠拟合。 置信度(confidence level) &emsp;置信度也称置信水平是指总体参数值落在样本统计值某一区间的概率，即对事件真实性的相信程度。 置信区间(confidence interval) &emsp;置信区间是指在某个置信水平下，样本统计值与总体参数值间误差的范围。置信区间越大，置信水平就越高。 1.5 常用公式和函数 欧氏距离(euclidean distance) &emsp;对于平面上的二点P1(x1,y1)，P2(x2,y2)欧氏距离定义为： 曼哈顿距离(街区距离） 闵可夫斯基距离 &emsp;对于二个n维的变量A(x1,x2,…,xn)和B(y1,y2,…yn)，闵氏距离为： 海明距离 &emsp;在信息论中，二个字符串之间的海明距离是二个字符串对应位置的不同字符数。 &emsp;如：A=(1011101)，B=(1001001) &emsp;海明距离=2 杰卡德(Jaccard)相似度 &emsp;J(A,B) = |A∩B| / |A∪B| &emsp;其中A，B为集合 &emsp;如网页相似度比较 文本编号 内容 A 努力建设国家级自然保护区 B 保护自然保护区义不容辞 &emsp;①分词处理： &emsp;A ={‘努力’，‘建设’，‘国家级’，‘自然保护区’｝&emsp;B ={‘保护’，‘自然保护区’，‘义不容辞’｝ &emsp;②计算相似度： &emsp;A∩B = ｛‘自然保护区’｝ &emsp;A∪B ={‘努力’，‘建设’，‘国家级’，‘自然保护区’，‘保护’，‘义不容辞’｝ &emsp;J(A,B) = 1/6 = 0.17 余弦相似度 &emsp;对于向量a(x1,y1)和b(x2,y2)的余弦值为： &emsp;对于n维时，若x=(x1,x2,…,xn)，y=(y1,y2,…,yn) &emsp;例：网页文本相似度计算 文本编号 内容 A 数据价值是一种数据艺术 B 算法价值是一种算法艺术 &emsp;① 分词处理： &emsp;A={‘数据’,‘价值’,‘是’,‘一种’,‘数据’,‘艺术’} &emsp;B={‘算法’,‘价值’,‘是’,‘一种’,‘算法’,‘艺术’} &emsp;② 计算并集 &emsp;A∪B={‘数据’,‘价值’,‘是’,‘一种’,‘算法’,‘艺术’} &emsp;③ 词频计算： &emsp;A={数据(2),价值(1),是(1),一种(1),算法(0),艺术(1)} &emsp;B={数据(0),价值(1),是(1),一种(1),算法(2),艺术(1)} &emsp;④ 建立特征向量： &emsp;A=(2,1,1,1,0,1) &emsp;B=(0,1,1,1,2,1) &emsp;⑤ 相似度计算： &emsp;余弦相似度更侧重于方向问题。 先验概率 &emsp;事件A发生的概率记为P(A)，这个先验概率值可以用相对频率来近似。根据大数定律，当训练集包含足够多的独立同分布样本时P(A)可通过样本出现的频率来估算。 联合概率 &emsp;事件A和事件B同时发生的概率，记为P(A,B)。 &emsp;若事件A和事件B相互独立，则： &emsp;P(A,B) = P(A) ×P(B) 条件概率(后验概率) &emsp;在事件A发生的条件下，事件B发生的概率，记为P(B|A) &emsp; P(B|A) = P(A,B)/P(A) 正态分布(高斯分布) &emsp;连续型随机变量x的概率密度为： 符号函数 指示函数 损失函数 &emsp;损失函数也称代价函数，可用于度量模型预测错误的程度，它是一个非负实值函数。 &emsp;令假设空间H中选取模型f作为决策函数，对于给定的输入x，由f(x)得到预测结果(输出)。这个输出值f(x)与真实值y可能一致也可能不一致，那么根据情况可选择一个损失函数来度量预测错误的程度，记为L(y,f(x))。 阶越函数（step function) Sigmoid函数（S型函数） 正则化（regularizayion) &emsp;用一组与原不适定问题相邻近的适定问题的解去逼近原问题的解的方法称为正则化方法。 &emsp;不适定问题：很难求解的问题 &emsp;正则化的目的：防止过拟合 &emsp;正则化的本质：约束(限制)要优化的参数 &emsp;正则化通过添加一些约束，使原问题解空间得到了压缩，简化了模型。 &emsp;正则化公式： &emsp;L1正则： &emsp;L2正则 &emsp;L1+ L2 其中第一项L（θ）是损失函数，第二项为正则化项或者称为惩罚项。 1.6 测试集组织&emsp;模型性能好坏一个简单的评价方法可以用模型的错误率来衡量。我们构建的模型不是对已有样例的重新预测或分类，而是要对未来样例的预测或分类，即模型的泛化能力。通常我们可以通过实验测试来评估模型，这就需要一个测试集。 &emsp;测试样例的组织： &emsp;假设已有m个样本D={x1,x2,…,xm}，从D中挑选部分样例组成训练集，再从D中挑选部分样例组成测试集。 &emsp;问题：如何挑选？ 留出法(hold-out) &emsp;将D划分为二个不相交的集合S和T，其中D=S∪T，S∩T=Ф &emsp;如D包含了1000个样例，划分后，S包含700个训练样本，T包含了300个测试样本。如果模型在T上有90个样本预测错误，则错误率为：E=90/300=0.3，错误率为30%。 &emsp;这种方法需注意的： &emsp;① 训练集/测试集的划分尽可能地保持数据分布的一致性，避免因样例划分过程引入额外的偏差。 &emsp;② 存在多种划分组合，每种划分都对应了模型的评估性能，所以单次使用留出法得到的评估结果往往是不够稳定可靠的。改进的方法是采用若干次随机划分取平均值作为留出法的评估结果。 &emsp;③ 划分时如果S较大接近于D时，用S训练出的模型更接近于用D训练出的模型，但此时T较小，评估结果可能不准确；若T较大时，用S训练出的模型与用D训练出的模型有较大的差别，将降低评估结果的真实性。通常划分的比例为2/3～4/5的样例作为训练集，其余作为测试集。 交叉验证法(cross validation) &emsp;将样本数据集D划分为k个大小相似的互斥子集，即D=D1∪D2∪…∪Dk，其中：Di∩Dj=Ф (i≠j) &emsp;划分时同留出法尽量保持每个子集数据一致性，然后每次用k-1个子集的并集作为训练集，剩余的一个子集作为测试集，这样共获得k组训练/测试集，相应地可进行k次训练和测试。用k次测试结果的平均值作为模型的性能评估值。 自助法(bootstrapping) &emsp;每次从D中随机挑选一个样例拷贝到D’中且该样例仍保留在D中，下次挑选时仍可能被选中。重复从D中挑选m个样例到D’中，此时D’中可能某个样例出现多次，而D中某些样例可能不在D’中。 &emsp;估算样例在m次挑选中未被选中的概率为:]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用算法总结(一) 基本概念、线性表]]></title>
    <url>%2F2019%2F01%2F01%2F%E5%AE%9E%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93(%E4%B8%80)%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[基本概念&emsp;算法的特征：有穷性、确定性、可行性、输入、输出 &emsp;程序=算法+数据结构 典型问题： 800电话号码有如下的格式：800-8222657，其中有效的800免费电话不超过800万个，比如不存在以0或1开头的有效免费电话。现要求对这些800免费电话号码进行排序，要求内存不超过1MB。 &emsp;解题思路：位图法 &emsp; 每个7位的十进制整数表示一个小于1000万的整数，我们使用一个具有1000万个位的字符串来表示这个文件，其中，当且仅当整数i在文件中存在时，第i位为1。 &emsp;若给定表示文件中整数集合的位图数据结构，则可以分为三个自然阶段来编写程序。 &emsp;第一阶段将所有位都置为0，从而将集合初始化为空。 &emsp;第二阶段通过读入文件中的每个整数来建立集合，将每个对应位置为1。 &emsp;第三阶段检验每一位，如果该位为1，则输出对应的整数，由此产生有序的输出文件。 &emsp;令n为位向量中的位数（在本例子中为100000000），程序可以用如下伪代码表示如下： 12345678910/* phase 1:initialize set to empty */ for i =[0,n) bit[i]=0/* phase 2:insert present elements into the set */ for each i in the input file bit[i]=1/* phase 3:write sorted output */ for i =[0,n) if bit[i]==1 write i on the output file 从2.5亿个整数中找出不重复的数字的个数。可用的内存限定为600M；要求算法尽量高效，最优。 从1亿个整数中找出最大的1万个。 评估算法： 基本要求：正确性、可读性、健壮性（有异常处理机制） 更实用的要求：（性能） 高效率（时间复杂度低） 低存储量（内存开销小） 线性表数据结构数据结构包括逻辑结构和存储结构/物理结构 逻辑结构从逻辑关系上对数据结构进行描述 是从具体问题抽象出来的数据模型 与数据本身的存储（数据元素的存储位置、类型和具体取值）无关。 如： 线性结构：线性表； 非线性结构：树、图； 四类数据结构： 集合结构 &emsp;&emsp;元素间无任何关系，即关系结合是空集：S={} 线性结构 元素之间的关系是1:1 除了头结点外，所有结点有且仅有一个直接前驱。 除了尾结点外，所有结点有且仅有一个直接后继。 树形结构： 如，一般树、二叉树、森林 一个结点可有多个直接后继（除了叶子结点外） 但只有一个直接前驱（除了根节点外） 图形结构 元素之间的关系是m:n 一个结点可以有多个直接后继，也有多个直接前驱。 存储结构/物理结构数据结构在计算机中的表示（或映像） &emsp;顺序映像：顺序存储结构 &emsp;非顺序映像：链式存储结构 &emsp;如，线性表有顺序表和链表两种物理存储方式 它可以借助于具体某程序语言中的“数据类型”来定义它。也可采用typedef将类型名重命名，以增加代码的可读性。 12345678910//顺序表数据存储结构的实现int Sqlist[100]; //单链表数据存储结构的实现struct Node&#123; int data; struct Node *next&#125;;Typedef struct Node *Link;Link head; 线性表什么是线性表？ &emsp;有限个数据元素组成的序列，记作(a1,a2, … , an) 逻辑特征：线性特征 存储结构：顺序表和链表两种方式 基本操作: &emsp; 创建空的线性表 &emsp; 销毁已有线性表 &emsp; 查找直接后继和直接前驱 &emsp;插入一个元素 &emsp; 删除一个元素 顺序表的定义与实现顺序表:在内存中连续存储的线性表 特性： 逻辑上相邻的元素，物理存储地址必相邻 ； 可随机存取：通过顺序表的名称和下标可以直接访问顺序表中的任一个元素。 静态定义：利用数组 方案一： 1int Sqlist[100]; 方案二： 12#define List_Size 100 /*分配空间的大小*/int Sqlist[List_Size ]; 方案三：（通用性最强，类似STL:vector） 123456#define List_Size 100/*分配空间的大小*/Typedef Struct&#123;int elem[List_Size ]; /*存储空间*/int len; /*实际长度*/&#125;SqList_static;/*“顺序表”数据存储结构的实现；描述了List_Size个int型变量组成的集合，且隐含着可利用下标[]来描述两个int型变量间的联系.*/ 评价: &emsp;该结构比较机械分配的内存空间大小固定。 &emsp;List_Size 过小，会导致顺序表上溢； &emsp;List_Size过大，会导致空间利用率不高 &emsp;在编译的时候，系统在函数栈中分配连续的内存空间。当静态顺序表所在的函数执行完毕后，由系统来回收所开辟的内存空间。 &emsp;程序运行时，出现上溢问题，将没法修补。 动态定义：利用指针123456#define List_Size 100 /*分配空间的大小*/typedef struct&#123; int *elem; /*顺序表的存储空间*/ int len; /*实际长度*/ int ListSize ; /*当前分配的空间大小*/ &#125; Sqlist; 特点： 需手动分配存储空间:malloc() 可以在程序运行过程中，重新分配空间：realloc() 不再使用顺序表时，需手动释放所占的空间：free() 可以避免“机械”，但是会增加时间开销。 C语言中的动态分配与释放函数： 123456Void *malloc(unsigned int size)/*生成一个大小为size的结点空间，将该空间的起始地址赋给p*/Free(void *p)/*回收p所指向的结点空间*/Void *realloc(void *p, unsigned int size)/*重新分配大小为size的结点空间，并将该空间的起始地址赋给p */ 构造一个空的顺序表： 123456789Int InitSqList(SqList *L)//构造一个空的顺序表L&#123; L-&gt;elem=(int *) malloc(List_Size *sizeof(int)); if (L-&gt;elem==NULL) exit(EXIT_FAILURE); L-&gt;len=0; L-&gt;ListSize =List_Size; return 1;&#125; 两种定义的对比总结： 不同：分配存储空间的方式不同 静态定义的顺序表由系统自动分配和回收存储空间； 动态定义的顺序表需要手动分配和回收存储空间，但是也可以再分配。 因而它们创建和销毁顺序表两种操作的实现不同， 相同点： &emsp;本质上都是存储在连续空间上，因而对数据的操作方式（查找，插、删）都是一样的。 顺序表：插入操作的实现 参数： 顺序表&amp;L、插入位置i、插入元素e 插入分析： 第i个位置放e，则原来第i~L.len个数据元素必须先后移，以腾出第i个位置; 后移的顺序为：从最后一个元素开始，逐个往后移 算法流程图： 代码：12345678910111213141516171819Status ListInsert_Sq( SqList &amp;L, int i, ElemType e) &#123; // 位置合法性的判断，合法的位置：i:1..L.len+1 if ( i&lt;1 || i&gt;L.len +1 ) return 0; // 上溢时，要先申请一个有一定增量的空间：申请成功则原空间的元素复制到新空间，修改L.listsize，再进行插入工作；否则报错退出。 if( L.len &gt;= L.listsize) &#123; newbase = (ElemType *) realloc(L.elem,(L.listsize+ LISTINCREMENT)*sizeof(ElemType)); if ( newbase == NULL ) exit(OVERFLOW); L.elem = newbase; L.listsize += LISTINCREMENT; &#125; // 插入元素 for ( j = L.len; j &gt;= i; j--) L.elem[j] = L.elem[j-1]; L.elem[i-1] = e; L.len++; return 1;&#125; 时间复杂度分析： &emsp;最好：插入位置为n+1,时间复杂度O（1） &emsp;最坏：插入位置为1，时间复杂度O(n） &emsp;平均：O(n） 顺序表：删除操作的实现 参数： &emsp;顺序表&amp;L、删除位置i 删除分析： &emsp;去掉第i个元素，则原来第i+1~L.len个数据元素须前移，以覆盖第i个位置; 算法流程图： &emsp;代码： 123456789Status ListDelete_Sq( SqList &amp;L, int i) &#123; // 位置合法性的判断 if ( i&lt;1 || i&gt;L.len ) return 0; // 删除 for ( j = i; j &lt; L.len ; j++) L.elem[j-1] = L.elem[j]; L.len--; return 1;&#125; 时间复杂度分析： &emsp;最好：删除位置为n,此时无须移动元素，时间复杂度为O(1); &emsp;最坏：删除位置i为1，此时无须移动元素，时间复杂度为O(1) &emsp;平均：O(n） 顺序表优缺点： 优点：随机存取。 弱点： 空间利用率不高（预先按最大空间分配） 表的容量不可扩充（针对顺序表的静态定义方案） 即使表的容量可扩充（针对顺序表的动态定义方案），由于其空间再分配和复制的开销，因而也不允许它频繁地使用 插入或删除时需移动大量元素。 适用环境例1：顺序文件的查找。（有序顺序表+二分查找） 例2：顺序文件的查找，并在文件中添加一个元素。（基于二叉平衡树的查找） 结论：顺序表适用于输入数据的大小已知，且无太多动态操作的应用问题。 链表的定义与实现 链表由一连串结点组成。 结点： 是链表元素的存储映像。 每个结点包括数据域和指针域。 指针：即链，它用于将结点们联系起来。也可以用于唯一定位一个结点。 头指针：链表存取的开始。 单链表：只有一个指针域的链表。 双链表：有两个指针域的链表。 结论：链表中用链来表明线性特征。 定义123456struct Node&#123; int data; struct Node *next&#125;;&#125;;Typedef struct Node *Link; Link head; 无头结点的单链表 &emsp;头指针为L，则空表时，L == NULL &emsp;由于第一个结点无前驱结点，所以只能通过某指针变量来指向，如L； &emsp;其余结点均有前驱结点，故可通过其直接前驱结点的next域来指向，即……-&gt;next；表示方法的不同，会造成对结点的操作处理的不同 有头结点的单链表 &emsp;空表时，L指向一结点(称为头结点)，该结点的数据域可以不存储信息，也可存储如表长等的附加信息，结点的指针域存放NULL，即L-&gt;next == NULL。 &emsp;第一个结点和其余结点均可统一表示为其直接前驱结点的next域所指向的结点，即……-&gt;next。 插入操作ListInsert_L(LinkList &amp;L, int i, ElemType e) 【设计思路】 相关结点：ai-1和ai 结点的表示：引入指针变量LinkList p; 关键步骤： ①找到ai-1 的位置，即使p指向ai-1 结点 若p≠NULL，则 ② s = (LinkList)malloc(sizeof(LNode)) ③ s-&gt;data = e ④ s-&gt;next = p-&gt;next ⑤ p-&gt;next = s 注意：④和⑤不能交换，否则会导致ai的位置无法获取。 时间复杂度分析：频度最高的操作：确定ai-1 的位置 若线性表长度为n，则： 最好情况：T(n)=O(1) 最坏情况：T(n)=O(n) 平均情况：T(n)=O(n) 代码： 有头结点的单链表中的插入算法： 12345678910111213141516171819202122 // 有头结点，无须对i为1的插入位置作特殊处理Status ListInsert(LinkList &amp;L, int i, ElemType e)&#123; // 对p,j初始化; *p为L的第j个结点 p = L; j = 0; // 寻找第i-1个结点的位置 while( p != NULL &amp;&amp; j&lt;i-1) &#123; p = p-&gt;next; j++; &#125; // i小于1或大于表长的异常处理 if( p == NULL || j&gt;i-1) return ERROR; s = (LinkList )malloc(sizeof(LNode)); // 生成新结点 if ( s == NULL ) exit(OVERFLOW);// 空间分配不成功，报错返回 s-&gt;data = e; s-&gt;next = p-&gt;next;// 插入L中 p-&gt;next = s; return OK; &#125; 无头结点的单链表中的插入算法 12345678910111213141516171819202122232425262728293031Status ListInsert(LinkList &amp;L, int i, ElemType e) &#123; // 无头结点，须对i为1的插入位置作特殊处理 if ( i==1) &#123; s = (LinkList )malloc(sizeof(LNode)); // 生成新结点 if ( s == NULL ) exit(OVERFLOW); // 空间分配不成功，报错返回 s-&gt;data = e; s-&gt;next = L; // 插入到链表L中 L = s; // 修改链头指针L &#125; else &#123; p = L; j = 1; // 对p,j初始化; *p为链表的第j个结点 while( p != NULL &amp;&amp; j&lt;i-1) &#123; p = p-&gt;next; j++; // 寻找第i-1个结点的位置 &#125; if( p == NULL || j&gt;i-1) return ERROR;// i小于1或大于表长 s = (LinkList )malloc(sizeof(LNode)); // 生成新结点*s if ( s == NULL ) exit(OVERFLOW); // 空间分配不成功，报错返回 s-&gt;data = e; s-&gt;next = p-&gt;next; // 插入到链表L中 p-&gt;next = s; &#125; return OK; &#125; 删除操作【设计思路】 相关结点：ai-1、ai和ai+1 结点表示：p, (p-&gt;next),*(p-&gt;next-&gt;next) 关键步骤： ①找到ai-1 的位置，即使p指向ai-1 结点p-&gt;next≠NULL（有待删除的结点），则 ② q = p-&gt;next (记录待释放结点的位置) ③ p-&gt;next = p-&gt;next-&gt;next ④ free(q) 注意：必须在③④前增加②步，否则在执行了③后要释放的结点无法标识。 创建操作 头插法 &emsp;每次将待插结点*s插入到第一个结点之前；当有头结点时，待插结点也可视为插入到第0个结点(头结点)之后。 &emsp;有头结点的插入步骤： &emsp;① s = (LinkList)malloc(sizeof(LNode)) &emsp;② scanf(&amp;s-&gt;data) &emsp;③ s-&gt;next = L-&gt;next &emsp;④ L-&gt;next = s &emsp;算法时间复杂度分析： &emsp;每次插入一个结点所需的时间为O(1)，因此头插法创建单链表的时间复杂度 T(n) = O(n) 尾插法： &emsp;待插结点*s插入到最后一个结点之后 插入步骤： &emsp;① 获得最后一个结点的位置,使p指向该结点 &emsp;② p-&gt;next = (LinkList)malloc( sizeof(LNode)) &emsp;③ p = p-&gt;next &emsp;④ scanf( &amp;p-&gt;data ) &emsp;⑤ p-&gt;next = NULL 算法时间复杂度分析： &emsp;要想获取最后一个结点的位置，必须从链头指针开始顺着next链搜索链表的全部结点，该过程的时间复杂度是O(n)。如果每次插入都按此方法获取最后一个结点的位置，则整个创建算法的时间复杂度为T(n) = O(n2)。 循环链表问题一：如何从一个结点出发，访问到链表中的全部结点 循环链表 循环链表与单链表的差异： 类型定义不变； 最后一个结点的指针不为空，而是指向表头结点（头结点/第一个结点）； 搜索表时，结束条件不再是看其是否为NULL，而是看其是否等于头指针 问题二：对于循环链表，如何在O(1)时间内由链表指针访问到第一个结点和最后一个结点 头指针表示法： 第一个结点：*(la-&gt;next)&emsp;&emsp; T(n)=O(1) 最后一个结点：需从表头搜索到表尾 &emsp;T(n)=O(n) 尾指针表示法： 第一个结点：*(ra-&gt;next-&gt;next)&emsp; T(n)=O(1) 最后一个结点：*ra &emsp; T(n)=O(1) 双向链表单链表的缺点：只知其直接后继结点，不知当前结点的直接前驱。 巧妙的解决方案：双向链表 &emsp;1）Link prev; curr=prev-&gt;next; &emsp;2）Link prev; curr = prev （处理链表的一个子集时很方便） 每个结点有2个链：分别指向逻辑相邻的2个结点。可在O(1)时间内找到一个结点的直接前驱结点和直接后继结点广泛应用，如STL:list 特点：若d指向表中的一个内部结点，则d-&gt;next-&gt;prior == d-&gt;prior-&gt;next == d 定义： 12345678910Struct Node&#123;ElemType data;struct Node *prior;struct Node *next;&#125;;typedef struct Node * Link;typedef struct &#123;Link head, tail;int len;&#125;DLinkList; 线性表的应用例1：将两个线性表合并为一个线性表； 例2：将按值非递减有序的两个线性表合并为一个有序线性表 ； 参考资料：【1】中科大余艳玮老师实用算法课程 【2】[程序员实用算法].Andrew.Binstock.等著 【3】《编程珠玑(第2版)》]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文对排序算法做一次总结和梳理，主要思想+实例+代码实现+时间空间复杂度分析 基于比较的排序算法交换类排序 冒泡排序 基本思想连续的扫描待排序的记录；每趟扫描时，都会移动最大的记录，使之更接近于序列的尾部，像气泡一样缓缓上升。 若某趟扫描过程中没有执行任何交换，则表明记录是有序的，因而需终止排序。 如何移动最大的记录，使之更接近于序列的尾部？ 将当前记录与下一条记录进行比较，若当前记录&gt;下一条记录，则交换两条记录的位置。 实例5 4 3 6 1 从小到大排序 第一趟：从头到尾，两两比较，不符合前小后大，就交换位置。 5和4比较，5比4大，交换位置，接着5和3比较，5比3大，交换位置，5再和6比较，不交换，6和1比较，6比1大，两者交换位置，一趟排序下来，变为 4 3 5 1 6 此时最大的数字6，已经像气泡一样上升到了最后，它的位置就已经确定，下次比较，就只需要对前面4个数字进行排序 第二趟： 4和3比较，交换，4再和5比较，不交换，5和1比较，交换，此趟结束，那么一趟排序下来，变为了 3 4 1 5 6 5也升到了最后，也就是一次排序有一个数字到达了最终位置，第一趟是最后一个数，第二趟是倒数第二个数，因此下次只用对前面的数进行排序。 第三趟： 只用对3 4 1 排序，排序下来变为 3 1 4 5 6 第四趟： 只用对 3 1排序 1 3 4 5 6 第五趟:只有一个1，排序完成 最终就是 1 3 4 5 6 实现代码整个排序过程可以用两层循环完成，代码如下：12345678910111213141516171819void BubbleSort(int *a, int length)&#123; int i,temp,flag; for (i = 0;i &lt; length - 1;i++) &#123; flag=0; for (int j = 0;j &lt; length - i - 1;j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; flag=1; &#125; &#125; if(flag==0) break; &#125;&#125; 快速排序 选择类排序 简单选择排序 堆排序 插入类排序 直接插入排序 折半插入排序 希尔排序 基于某种映射函数的排序算法 桶排序 基数排序]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scikit-learn学习笔记（一）]]></title>
    <url>%2F2018%2F12%2F23%2Fskicit-learn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[scikit-learn是一个python的库，包含大量的机器学习算法。由于做kaggle上面的项目需要，使用到了这个库，但是需要注意的是scikit-learn的数据必须是numeric类型的。 安装前提:有python，且安装好了numpy库和scipy库，然后通过pip的方式安装如下： 1pip install -U sickit-learn 选择模型方法官网中有流程图，对于不同的场景需要选择不同的机器学习模型，模型图如下： 图中蓝色的圆圈是判断，绿色的方框是可以选择的算法。 算法分为了四大类： classfication(分类）、regression（回归）、clustering（聚类）、dimensionality reduction（数据降维） 数据集利用 scikit-learn中包含了很多技术集，可供学习。 比如iris数据集，中文名是安德森鸢尾花卉数据集，是一个给鸢尾花做分类的数据集，包含四个属性： 花萼长度、花萼宽度、花瓣长度、花瓣宽度 以及花的品种：山鸢尾、变色鸢尾、维吉尼亚鸢尾 根据四个属性预测出花的品种，是一个典型的分类问题，可以根据这个数据集，走一下sickit-learn的使用流程 使用流程以iris数据集为例子： 导入数据集 查看数据格式 可以看出，每条数据有四个属性，标签一共有三类，用0、1、2表示。 划分数据集 train_test_split可以随机划分数据集，要划分的是iris_X和iris_y，划分比例是训练数据80%,测试数据20% 使用模型、预测、计算准确率 使用knn模型，至于此模型的原理，不是本文重点，不再解释。 打印出的结果可以看到模型预测的结果不一定是完全准确的。可以通过以下方式计算模型的准确率： 训练数据准确率为96%左右，测试数据准确率为93%左右，说明使用knn做鸢尾花数据集的分类是一个不错的选择。 参考：莫烦的学习网站]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
