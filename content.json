{"meta":{"title":"YangJie's Blog","subtitle":null,"description":null,"author":"YangJie","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-12-24T11:29:37.000Z","updated":"2018-12-24T12:41:09.543Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-12-24T11:29:21.000Z","updated":"2018-12-24T12:40:43.863Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-24T11:28:46.000Z","updated":"2018-12-24T12:40:33.404Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"排序算法总结","slug":"排序算法总结","date":"2018-12-25T02:04:48.000Z","updated":"2018-12-26T12:22:25.834Z","comments":true,"path":"2018/12/25/排序算法总结/","link":"","permalink":"http://yoursite.com/2018/12/25/排序算法总结/","excerpt":"","text":"本文对排序算法做一次总结和梳理，主要思想+实例+代码实现+时间空间复杂度分析 基于比较的排序算法交换类排序 冒泡排序 基本思想连续的扫描待排序的记录；每趟扫描时，都会移动最大的记录，使之更接近于序列的尾部，像气泡一样缓缓上升。 若某趟扫描过程中没有执行任何交换，则表明记录是有序的，因而需终止排序。 如何移动最大的记录，使之更接近于序列的尾部？ 将当前记录与下一条记录进行比较，若当前记录&gt;下一条记录，则交换两条记录的位置。 实例5 4 3 6 1 从小到大排序 第一趟：从头到尾，两两比较，不符合前小后大，就交换位置。 5和4比较，5比4大，交换位置，接着5和3比较，5比3大，交换位置，5再和6比较，不交换，6和1比较，6比1大，两者交换位置，一趟排序下来，变为 4 3 5 1 6 此时最大的数字6，已经像气泡一样上升到了最后，它的位置就已经确定，下次比较，就只需要对前面4个数字进行排序 第二趟： 4和3比较，交换，4再和5比较，不交换，5和1比较，交换，此趟结束，那么一趟排序下来，变为了 3 4 1 5 6 5也升到了最后，也就是一次排序有一个数字到达了最终位置，第一趟是最后一个数，第二趟是倒数第二个数，因此下次只用对前面的数进行排序。 第三趟： 只用对3 4 1 排序，排序下来变为 3 1 4 5 6 第四趟： 只用对 3 1排序 1 3 4 5 6 第五趟:只有一个1，排序完成 最终就是 1 3 4 5 6 实现代码整个排序过程可以用两层循环完成，代码如下：12345678910111213141516171819void BubbleSort(int *a, int length)&#123; int i,temp,flag; for (i = 0;i &lt; length - 1;i++) &#123; flag=0; for (int j = 0;j &lt; length - i - 1;j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; flag=1; &#125; &#125; if(flag==0) break; &#125;&#125; 快速排序 选择类排序 简单选择排序 堆排序 插入类排序 直接插入排序 折半插入排序 希尔排序 基于某种映射函数的排序算法 桶排序 基数排序","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"scikit-learn学习笔记（二）","slug":"scikit-learn学习笔记(二)","date":"2018-12-24T12:22:00.000Z","updated":"2018-12-24T12:32:04.234Z","comments":true,"path":"2018/12/24/scikit-learn学习笔记(二)/","link":"","permalink":"http://yoursite.com/2018/12/24/scikit-learn学习笔记(二)/","excerpt":"","text":"123","categories":[],"tags":[]},{"title":"scikit-learn学习笔记（一）","slug":"skicit-learn学习笔记(一)","date":"2018-12-23T08:24:49.000Z","updated":"2018-12-24T12:34:33.074Z","comments":true,"path":"2018/12/23/skicit-learn学习笔记(一)/","link":"","permalink":"http://yoursite.com/2018/12/23/skicit-learn学习笔记(一)/","excerpt":"","text":"scikit-learn是一个python的库，包含大量的机器学习算法。由于做kaggle上面的项目需要，使用到了这个库，但是需要注意的是scikit-learn的数据必须是numeric类型的。 安装前提:有python，且安装好了numpy库和scipy库，然后通过pip的方式安装如下： 1pip install -U sickit-learn 选择模型方法官网中有流程图，对于不同的场景需要选择不同的机器学习模型，模型图如下： 图中蓝色的圆圈是判断，绿色的方框是可以选择的算法。 算法分为了四大类： classfication(分类）、regression（回归）、clustering（聚类）、dimensionality reduction（数据降维） 数据集利用 scikit-learn中包含了很多技术集，可供学习。 比如iris数据集，中文名是安德森鸢尾花卉数据集，是一个给鸢尾花做分类的数据集，包含四个属性： 花萼长度、花萼宽度、花瓣长度、花瓣宽度 以及花的品种：山鸢尾、变色鸢尾、维吉尼亚鸢尾 根据四个属性预测出花的品种，是一个典型的分类问题，可以根据这个数据集，走一下sickit-learn的使用流程 使用流程以iris数据集为例子： 导入数据集 查看数据格式 可以看出，每条数据有四个属性，标签一共有三类，用0、1、2表示。 划分数据集 train_test_split可以随机划分数据集，要划分的是iris_X和iris_y，划分比例是训练数据80%,测试数据20% 使用模型、预测、计算准确率 使用knn模型，至于此模型的原理，不是本文重点，不再解释。 打印出的结果可以看到模型预测的结果不一定是完全准确的。可以通过以下方式计算模型的准确率： 训练数据准确率为96%左右，测试数据准确率为93%左右，说明使用knn做鸢尾花数据集的分类是一个不错的选择。 参考：莫烦的学习网站","categories":[],"tags":[]}]}