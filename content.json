{"meta":{"title":"YangJie's Blog","subtitle":null,"description":null,"author":"YangJie","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-12-24T11:29:37.000Z","updated":"2018-12-24T12:41:09.543Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-24T11:28:46.000Z","updated":"2019-01-02T11:55:11.243Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-12-24T11:29:21.000Z","updated":"2019-01-02T11:51:09.140Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript笔记（四）","slug":"JavaScript深入浅出笔记（四）","date":"2019-03-04T08:16:59.000Z","updated":"2019-04-03T03:14:34.326Z","comments":true,"path":"2019/03/04/JavaScript深入浅出笔记（四）/","link":"","permalink":"http://yoursite.com/2019/03/04/JavaScript深入浅出笔记（四）/","excerpt":"","text":"数组javascript数组是弱类型的，数组中可以含有不同类型的元素，数组元素甚至可以是对象或其他数组 1var arr=[1,true,null,undefined,&#123;x:1&#125;,&#123;1,2,3&#125;]; 创建数组-字面量12var commasArr1=[1,,2];//1,undefined,2var commasArr2=[,,];//undefined*2,最后一个undefined被忽略 数组的大小0-(2^23-1) 创建数组-new Array12var arr=new Array();var arrWithLength=new Array(100)//undefined*100 数组元素读写12345678910var arr=[1,2,3,4,5];arr[1];//2arr.length;//5arr[5]=6;arr.length;//6delete arr[0];//并不会改变数组长度arr[0];//undefined0 in arr;//false 数组元素增删js的数组是动态，无需指定大小 1234567arr.push(3);//在末尾加元素arr.unshift(0);//在头部加元素arr.length-=1;//也可以删除尾部元素arr.pop();//尾部删除元素arr.shift();//删除头部元素 数据迭代for循环，或者for in(不保证顺序，同时注意原型也会出现，可以用hasOwnProperty判断) 二维数组1var arr=[[0,1],[2,3],[4,5]]; 稀疏数组稀疏数组并不含有从0开始的连续索引，一般length属性值比实际元素个数大（不常用） 数组方法joinArray.prototype.join将数组转为字符串 123456789var arr=[1,2,3];arr.join();//&quot;1,2,3&quot;arr.join();//&quot;1_2_3&quot;function repeatString(str,n)&#123; return new Array(n+1).join(str);&#125;repeatString(&quot;a&quot;,3);//&quot;aaa&quot;repeatString(&quot;Hi&quot;,5);//&quot;HiHiHiHiHi&quot; reverseArray.prototype.reverse将数组逆序 123var arr=[1,2,3];arr.reverse();//[3,2,1]arr;//[3,2,1] 原数组被修改 sortArray.prototype.sort默认按照字母顺序排序 123456789101112131415161718var arr=[13,24,51,3];arr.sort();//[13,24,3,51]arr.sort(function(a,b)&#123; return a-b;&#125;);//[3,13,24,51]arr=[&#123;age:25&#125;,&#123;age:39&#125;,&#123;age:99&#125;];arr.sort(function(a,b)&#123; return a.age-b.age;&#125;);arr.forEach(function(item)&#123; console.log(&apos;age&apos;,item.age);&#125;//result://age 25//age 39//age 99 concatArray.prototype.concat数组合并 123456var arr=[1,2,3];arr.concat(4,5);//[1,2,3,4,5]arr;//[1,2,3] 原数组并未被修改arr.concat([10,11],13);//[1,2,3,10,11,13] 参数数组会被拉平arr.concat([1,[2,3]);//[1,2,3,1,[2,3]] 但不会拉平两次 sliceArray.prototype.slice 切片，返回数组片段左闭右开区间,原数组未被修改 12345var arr=[1,2,3,4,5];arr.slice(1,3);//[2,3]arr.slice(1);//[2,3,4,5]arr.slice(1,-1);//[2,3,4]arr.slice(-4,-3);//[2] spliceArray.prototype.splice 数组拼接，第一个参数是索引，第二个参数想删除的元素的个数,后面无限个参数是添加的元素 1234567891011var arr=[1,2,3,4,5];arr.splice(2);//return [3,4,5]arr;//[1,2] 原数组被修改arr=[1,2,3,4,5];arr.splice(2,2);//returns[3,4]arr;//[1,2,5]arr=[1,2,3,4,5];arr.splice(1,1,&apos;a&apos;,&apos;b&apos;);returns[2]arr;//[1,&quot;a&quot;,&quot;b&quot;,3,4,5] 下面开始都是ES5 Array方法： forEachArray.prototype.forEach 123456789var arr=[1,2,3,4,5];arr.forEach(function(x,index,a)&#123; console.log(x+&apos;|&apos;+index+&apos;|&apos;+(a===arr)&#125;);//1|0|true//2|1|true//3|2|true//4|3|true//5|4|true mapArray.prototype.map 数组映射 12345var arr=[1,2,3];arr.map(function(x))&#123; return x+10;&#125;)//[11,12,13]arr;//[1,2,3] 原数组未被修改 filterArray.prototype.filter 数组过滤 12345var arr=[1,2,3,4,5,6,7,8,9,10];arr.filter(function(x,index)&#123; return index%3===0||x&gt;=8;&#125;);//returns [1,4,6,7,8,9,10]arr;//原数组未被修改 every&amp;someArray.prototype.every&amp;some 数组判断(类似逻辑与和逻辑或) 1234567891011121314151617var arr=[1,2,3,4,5];arr.every(function(x)&#123; return x&lt;10;&#125;);//truearr.every(function(x)&#123; return x&lt;3;&#125;);//falsevar arr=[1,2,3,4,5];arr.some(function(x)&#123; return x===3;&#125;);//truearr.some(function(x)&#123; return x===100;&#125;);//false reduce&amp;reduceRightArray.prototype.reduce&amp;reduceRight 1234567891011121314151617181920212223var arr=[1,2,3];var sum=arr.reduce(function(x,y)&#123; return x+y&#125;,0);//6 arr;//[1,2,3]arr=[3,9,6];var max=arr.reduce(function(x,y)&#123; console.log(x+&quot;|&quot;+y); return x&gt;y?x:y;&#125;);//3|9//9|6max;//9//redeceRight是从右边开始max=arr.reduceRight(function(x,y)&#123; console.log(x+&quot;|&quot;+y); return x&gt;y?x:y;&#125;);//6|9//9|3max;//9 indexOf&amp;lastIndexOfArray.prototype.indexOf&amp;lastIndexOf123456var arr=[1,2,3,2,1];arr.indexOf(2);//1arr.indexOf(99);//-1arr.indexOf(1,1);//4 从第二个元素开始查找arr.indexOf(1,-3);//4arr.lasrIndexOf(2);//从右往左找 isArrayArrar.isArray 判断是否为数组 12345Array.isArray([]);//true[] instanceof Array;//true(&#123;&#125;).toString.apply([])===&apos;[object Array]&apos;;//true[].constructor===Array;//true 数组小结数组VS一般对象相同点：都可以继承，数组是对象，对象不一定是数组，都可以当做对象添加删除属性 不同点：数组自动更新length，按索引访问数组常常比访问一般对象属性明显迅速。数组对象继承Array,prototype上大量数组操作方法 字符串VS数组123456var str=&quot;hello world&quot;;str.charAt(0);//&quot;h&quot;str[1];//eArray.prototype.join.call(str,&quot;_&quot;);//&quot;h_e_l_l_o_ _w_o_r_l_d&quot; 参考资料JavaScript深入浅出","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript笔记（三）","slug":"JavaScript深入浅出笔记（三）","date":"2019-03-04T08:13:43.000Z","updated":"2019-04-03T03:14:36.792Z","comments":true,"path":"2019/03/04/JavaScript深入浅出笔记（三）/","link":"","permalink":"http://yoursite.com/2019/03/04/JavaScript深入浅出笔记（三）/","excerpt":"","text":"对象基本概念对象中包含一系列属性，这些属性是无序的。每个属性都有一个字符串key和对应的value。 123var obj=&#123;x:1,y:2&#125;;obj.x;//1obj.y;//2 创建对象、原型链对象创建： 创建对象-字面量123456789var obj1=&#123;x:1,y:2&#125;;var obj2=&#123; x:1, y:2, o:&#123; z:3, n:4 &#125;&#125;; 创建对象-new/原型链12345678910111213141516171819202122232425262728function foo()&#123;&#125;;foo.prototype.z=3var obj=new foo();obj.y=2;obj.x=1;obj.x;//1obj.y;//2obj.z;//3typeof obj.toString;//&apos;function&apos;z in obj;//trueobj.hasOwnProperty(&apos;z&apos;);//falseobj.z=5;obj.hasOwnProperty(&apos;z&apos;);//truefoo.prototype.z;//still 3obj.z;//5obj.z=undefined;obj.z;//undefineddelete obj.z;//trueobj.z;//3delete obj.z;//trueobj.z;//still 3!!! 创建对象-Object.create1234567var obj=Object.create(&#123;x:1&#125;);obj.x;//1typeof obj.toString;//&quot;function&quot;obj.hasOwnProperty(&apos;x&apos;);//falsevar obj=Object.create(null);obj.toString;//undefined 属性类型数据属性[[configurable]]表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性 [[Enumberable]]表示能否通过for-in循环返回属性 [[Writeable]]表示能否修改属性的值 [[Value]]包含这个属性的数据值。读取属性值的时候，从这个位置读。写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。 对于直接在对象上定义的属性，他们的[[configurable]]、[[Enumberable]]、[[Writeable]]特性都被设置为true，而[[Value]]特性被设置为指定的值 访问器属性访问器属性不包含数据值，包含一对getter和setter函数（非必需），在读取访问器属性的时候，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据，访问器属性有如下四个特性： [[configurable]]表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性 [[Enumberable]]表示能否通过for-in循环返回属性 [[Get]]在读取属性时调用的函数。默认值为undefined [[Set]]在写入属性时调用的函数。默认值为undefined 12345678910111213141516171819var book=&#123; _year:2004,//下划线记号表示只能通过对象方法访问的属性。 edition:1&#125;;//year是访问器属性，包含一个getter函数一个setter函数，getter函数返回_year函数的值，setter函数通过计算来确定正确的版本Object.defineProperty(book,&quot;year&quot;,&#123; get: function()&#123; return this._year; &#125; set: function(newValue)&#123; if(newValue)&#123; this_year=newValue; this.edition+=newValue-2004; &#125; &#125;&#125;);book.year=2005;alert(book.edition);//2 只指定getter意味着属性不能写，只指定setter属性不能读。 属性操作读写对象属性123var obj=&#123;x:1,y:2&#125;;obj.x;//1obj[&quot;y&quot;];//2 使用Object.getOwnPropertyDescriptor()方法可以获得给定属性的描述符。这个方法接受两个参数：属性所在对象和要读取其描述符的属性名称 123var descriptor=Object.getOwnPropertyDescriptor(book,&quot;x&quot;);alert(descriptor.value);//1alert(descriptor.configurable);//true 属性异常(略)删除属性1234567var person=&#123;age:28,title:&quot;fe&quot;&#125;;delete person.age;//truedelete person[&apos;title&apos;];//trueperson.age;//undefineddelete person.age;//truedelete Object.prototype;//false不允许删除 检测属性1234567var cat=new Object;cat.legs=4;cat.name=&quot;Kitty&quot;;&apos;legs&apos; in cat;//true&apos;abc&apos; in cat;//false&quot;toString&quot; in cat;//true 枚举属性（略）属性getter/setter方法见前面 属性标签修改属性标签。用Object.defineProperty()方法；接受三个参数：属性所在的对象、属性的名字、描述符对象； 其中，描述符对象的属性必须是：configurable、enumerable、writable、value； 设置其中的一个或多个值，可以修改对应的特性值。一旦将confidurable特性改为false，不能再改回true。 在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable、writable特性的值都是false。 12345678var person=&#123;&#125;;Object.defineProperty(person,&apos;name&apos;,&#123;configurable:false;writable:false;enumerable:true;value:&quot;Bosn Ma&quot;&#125;);//多个属性用defineProperties 对象标签原型标签比如Object.prototype class标签toString 是 Object原型对象上的方法，使用Object.prototype.toString.call() 来调用该方法会返回调用者的类型字符串，返回格式为 [object,xxx]，xxx 是调用者的数据类型，包括：String、Number、Boolean、Undefined、Null、Function、Date、Array、RegExp、Error、HTMLDocument 等。 extensible标签表示对象是否可以扩展，即对象上的属性是否可以继续添加 1234567891011121314var obj=&#123;x:1,y:2&#125;;Object.isExtensible(obj);//trueObject.preventExtensions(obj);//变为不可扩展Object.isExtensible(obj);//falseobj.z=1;obj.z;//undefined,add new property failedObject.seal(obj)//设置对象属性标签不可被配置,设置confinurable为falseObject.isSealed(obj)//判断对象是否被隐藏Object.freeze(obj)//冻结，设置属性不可写Object.isFrozen(obj)//判断对象是否被冻结 对象序列化123456789var obj = &#123;x:1,y:true,z:[1,2,3],nullVal:null&#125;;JSON.stringify(obj)/*如果属性是undefined，就不会出现在序列中。NaN和Infinity会转换为null，时间会转为UTC时间格式*///把JSON转为对象obj=JSON.parse(&apos;&#123;&quot;x&quot;:1&#125;&apos;);obj.x;//1 其他对象方法toString() valueOf 参考资料JavaScript深入浅出","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript笔记（二）","slug":"JavaScript深入浅出笔记（二）","date":"2019-03-04T03:27:46.000Z","updated":"2019-03-04T08:14:19.045Z","comments":true,"path":"2019/03/04/JavaScript深入浅出笔记（二）/","link":"","permalink":"http://yoursite.com/2019/03/04/JavaScript深入浅出笔记（二）/","excerpt":"","text":"语句块block没有块级作用域 123456789&#123; var x=1; //....&#125;//等价于var x=1;&#123; //...&#125; var语句声明变量 try-catch语句1234567try&#123; throw &quot;tese&quot;;&#125;catch(ex)&#123; console.log(ex);//test&#125;finally&#123; console.log(&apos;finally&apos;);&#125; function语句12345fd();//truefunction fd()&#123; //do sth return true;&#125; 12345fe();//TypeErrorvr fe=function fd()&#123; //do sth return true;&#125; for…in 语句12345var p;var obj=&#123;x:1.y:2&#125;for(p in obj)&#123; &#125; 特点： 1、顺序不确定 2、enumerable为false时不出现 3、for in对象属性时受原型链影响 switch语句、循环语句（略）with语句12345678910with(&#123;x:1&#125;)&#123; console.log(x);&#125;with(document.forms[0])&#123; console.log(name.value);&#125;//相当于var form=document.forms[0];console.log(form.name.value); 不建议使用with语句： 1、让js引擎优化更难 2、可读性差 3、可被变量定义代替 4、严格模式下被禁用 严格模式严格模式是一种特殊的执行模式，它修复了部分语言上的不足，提供更强的错误检查，并增强安全性 1234567function func()&#123; &apos;use strict&apos;;&#125;//或整个js内使用&apos;use strict&apos;;function func()&#123;&#125; 严格模式有如下特点 1、 不允许使用with 2、不允许未声明的变量被赋值 3、arguments变为参数的静态副本 1234！function(a)&#123; arguments[0]=100; console.log(a);&#125;(1); 在一般模式下，如果定义了一个函数，调用它并且传递参数，那么它对应的形参和arguments[0]有一个相互的绑定关系，就是说如果我们修改了arguments[0]，那么这个函数对应的形参a就会被修改了，所以输出100。 1234！function(a)&#123; arguments[0]=100; console.log(a);&#125;(); 如果不给函数传值，那么无论我们如何修改arguments[0]的值，输出的都是undefined，因为没有传递参数进去 但是在严格模式下：arguments[0]变为参数的静态副本，就是说无论函数的参数有没有传递，都不会和arguments相互影响 12345！function(a)&#123; &apos;use strict&apos;; arguments[0]=100; console.log(a);//1&#125;(1); 但是如果传入的是一个对象的话，将会按照共享传递，使用arguments修改对象的属性，那么还是会相互影响的。12345! function (a)&#123; &apos;use strict&apos;; arguments[0].x=100; console.log(a.x);//100 &#125;(&#123;x:1&#125;); 4、delete参数、函数名报错 123！function(a)&#123; console.log(delete a);&#125;(1); 报false 严格模式下： 1234！function(a)&#123; &apos;use strict&apos;; console.log(delete a);&#125;(1); 报SyntaxError 语法错误 5、delete不可配置的属性报错 123456!function(a)&#123; var obj=&#123;&#125;; Object.definedProperty(obj,&apos;a&apos;,&#123;configurable:false&#125;); console.log(delete obj.a);&#125;(1);//false 1234567!function(a)&#123; &apos;use strict&apos;; var obj=&#123;&#125;; Object.definedProperty(obj,&apos;a&apos;,&#123;configurable:false&#125;); console.log(delete obj.a);&#125;(1);//TypeError 6、对象字面量重复属性名报错 1234!function()&#123; var obj=&#123;x:1,x:2&#125;;//以最后一个为准 console.log(obj.x);&#125; 123456!function()&#123; &apos;use strict&apos;; var obj=&#123;x:1,x:2&#125;;//以最后一个为准 console.log(obj.x);&#125;//SyntaxError 语法错误 7、禁止八进制字面量 123！function()&#123; console.log(0123);//八进制&#125; 严格模式下会报语法错误 8、eval,arguments变为关键字，不能作为变量、函数名，否则报语法错误 eval变为独立作用域 参考资料JavaScript深入浅出","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"JavaScript笔记（一）","slug":"JavaScript深入浅出笔记（一）","date":"2019-03-04T02:33:11.000Z","updated":"2019-03-04T03:07:11.445Z","comments":true,"path":"2019/03/04/JavaScript深入浅出笔记（一）/","link":"","permalink":"http://yoursite.com/2019/03/04/JavaScript深入浅出笔记（一）/","excerpt":"","text":"数据类型原始类型六种：Object number string boolean null undefined Object是对象类型，包括function、Array、Date等 “==”和“ ===”“===”是严格等于，要求数据类型和值都相等 1234567null===nullundefined=undefinedNaN≠NaN //注意new Object≠new Object “==”是等于，先进行类型转换,再进行比较 123456789null=undefinednumber== string //string转为number 1==&quot;1.0&quot; trueboolean==? //先把boolean转为number 比如1==trueobject==number/string //先把对象类型转为基本类型new String（“hi&quot;)==&quot;hi&quot; //true 类型检测typeoftypeof 适合基本类型及function检测，遇到null失效： 123typeof null //&quot;object&quot;typeof NaN //&quot;number&quot; {}.toString通过{}.toString拿到，适合内置对象和基本类型，遇到null和undefined失效（IE678等返回[object Object]) 1Object.prototype.toString.app([]);//&quot;[object Array]&quot; instanceof适合自定义对象，也可以用来检测原生对象，在不同iframe和window间检测时失效 123[1,2] instanceof Array===truenew object() instance of Array===false 表达式原始表达式常量,直接量 3,14 “test” 关键字 null this true 变量 i,j,k 复合表达式10*20 数组，对象的初始化表达式[1,2,3] [1,4] {x:1,y:2} 函数表达式123var a=function()&#123;&#125;;(function()&#123;console.log(&quot;hello world&quot;)&#125;)();//立即调用 属性访问表达式12345var o=&#123;x:1&#125;；o.xo[&quot;x&quot;] 调用表达式1fun(); 对象创建表达式123new Func(1,2);new Object; 运算符常见运算符一元：+num 二元：a+b 三元：c?a:b 按照功能分：赋值、比较、算术、位、逻辑、字符串、特殊 特殊运算符条件运算符 c?a:b 1var val=true?1:2;// val=1 逗号运算符 a,b 1var val=(1,2,3);//val=3,每个表达式都会计算，最后取最右边的值 删除对象的属性 delete obj.x; 1234567891011121314151617181920212223var obj=&#123;x:1&#125;;obj.x;//1delete obj.x;obj.x;//undefined//另一种情况：var obj=&#123;&#125;;Object.definedProperty(obj,&apos;x&apos;&#123; configurable:false,//true的时候才能删除。value:1&#125;);delete obj.x;//falseobj.x;//1 运算符instanceof typeof： 123&#123;&#125; instanceof Object; //truetypeof 100===&apos;number&apos; //true 运算符new: 1234567891011function Foo()&#123;&#125;Foo.prototype.x=1;var obj=new Foo();obj.x;//1obj.hasOwnProperty(&apos;x&apos;);//false，不是对象的属性obj._proto_hasOwnProperty(&apos;x&apos;);//true,对象原型上的属性 运算符this: 123456789this;//windows(浏览器)var obj=&#123; func:function()&#123;return this;&#125;&#125;;obj.func();//obj 运算符void: 1void 0 //undefined 参考资料JavaScript深入浅出","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"机器学习总结（七）集成学习","slug":"机器学习总结（七）集成学习","date":"2019-01-14T11:41:36.000Z","updated":"2019-01-15T06:23:24.379Z","comments":true,"path":"2019/01/14/机器学习总结（七）集成学习/","link":"","permalink":"http://yoursite.com/2019/01/14/机器学习总结（七）集成学习/","excerpt":"","text":"个体与集成集成学习通过构建并结合多个学习器来完成任务。 集成学习的一般结构为：一系列个体学习器采用某种策略结合在一起产生最终的输出。 同质：集成中个体学习器是同类型的，同质集成中个体学习器又称为“基学习器”，相应的学习算法称为“基学习算法” 异质：集成中个体学习器是不同类型的 弱学习器(weak learner)：泛化能力略优于随机猜测的学习器 要获得好的集成，要求个体学习器“好而不同”，即个体学习器要有一定的“准确性”，即不能太坏，并且要有“多样性”，即学习器之间有差异。 目前集成学习方法大致分为两大类，即个体学习器之间存在强依赖关系，必须串行生成的序列化方法，如Boosting，提升树等；以及个体学习器之间不存在强依赖关系，如Bagging和随机森林等。 Bagging方法要得到泛化能力强的集成，个体学习器应尽可能相互独立。虽然在现实任务中很难做到，但可以设法使个体学习器尽可能具有较大的差异性。一个可能的做法是对训练样本采样，产生出若干个不同的子集，再从每个子集中训练出基学习器。 Bagging采用自助采样方法训练基学习器。每个基学习器将针对学习问题的不同方面进行训练。 当采样生成了T个训练子集Di后，为每个训练子集Di分配一个基学习器hi，再将这些基学习器结合，按照某种策略产生最终的输出。一般情况下，分类任务输出时采用简单投票法，回归任务时采用简单平均法。若分类预测出现票数相同时，可随机选取一个类，或使用基学习器的置信度来确定。 Bagging算法的时间复杂度:假设基学习器的计算复杂度为O(n)，采样和投票的时间复杂度为O(m)，则Bagging算法的时间复杂度为T(O(m)+O(n))。相比较采样和投票的时间O(m)远小于O(n)，并且T通常是一个不太大的常数，所以训练一个Bagging集成与直接使用基学习算法训练一个学习器的复杂度同阶。这就表明Bagging是一个很高效的集成学习算法。 优点：泛化能力较强 缺点：训练误差较大 随机森林(Random Forest)随机森林是Bagging的一个改进版本，也是一种比较新的机器学习模型，它以决策树为基学习器，模型的预测结果等于各决策树预测结果的某种加权平均。 ● 对于分类问题，最终结果等于在决策树预测结果中出现次数最多的类别 ● 对于回归问题，最终结果等于决策树预测结果的平均值 随机森林建模的依据是：一棵树犯错的概率比较大，但很多棵树同时犯错的概率就比较小。例如针对某个分类问题，有3棵相互独立的决策树，它们独立预测的错误率为20％，当把它们组成一个随机森林，那么预测的错误率将下降到10.4％。由此看出，随机森林预测效果最重要的保证是森林中的决策树应相互独立。那么该如何随机产生对于使用同一个训练集样例训练的决策树呢？ 可以从以下三个层面引入决策树的随机性： ① 对于每棵决策树采用自助法从训练集中随机选取训练子集 ② 在确定划分属性时，并不遍历全部属性，而是随机挑选部分属性构成一个侯选属性子集，然后再在这个侯选属性子集中产生最优的划分属性。 令k为随机挑选属性的数目，则参数k控制了随机性的引入程度。若k=d，则与传统决策树相同；若k=1，则是随机选择一个属性进行划分，一般情况下，推荐k=lg2d。 ③ 在选择属性划分阈值时，并不求得最优的解，而是随机构成一个候选阈值集合，再选取此集合中最优的划分阈值。 提升(Boosting)方法夏皮尔(Schapire)提升尽管Bagging方法有很好的结果，但也存在一个严重的缺陷，即参与投票的基学习器之间是相互独立的，使用的训练数据都是随机选择的，所以各基学习器之间关联性较弱。为此可以设计一个更聪明也更加有效的机制，使学习器之间呈现互补状态，如每个学习器都选择不易被其他学习器感知的样例进行训练，这也是Schapire Boosting方法的主要思想: 1)串行生成训练子集并训练基学习器 2)根据上一个学习器的训练结果产生训练子集并训练新的学习器 3)三个基学习器组成一个三元组 假设有一个随机子集Di∈D，用它训练出第一个学习器h1，当在整个训练集D上测试这个分类器时，会出现一些错分类的样本。 接着创建另一个训练子集D2∈D，其50%的样例来自被h1正确分类的样例，另50%的样例来自被h1错误分类的样例。这意味着用h1分类D2中的样本效果不佳，如同随机分类的结果。用D2训练出第二个学习器h2。 创建第三个训练子集D3∈D，D3中样本选择用h1和h2分类结果不一致的样本训练得到学习器h3。 当一个新的样本输入时，集成分类器返回票数最多的结果。在夏皮尔提升方法中，三个分类器组成一个基本单元，递归应用此规则，可构建包含更多分类器的集成。 夏皮尔提升的问题： ① 假设每个基学习器的错误率&lt;ε,则分类器三元组的错误率&lt;ε，即夏皮尔方法提升了单个分类器的性能。但当这个三元组的错误率很低时，其他分类器很难得到同样低的错误率。换言之，用一个三元组和其他两个基分类器组成新的三元组后，集成分类器的性能就不会有多大的提升。 解决方法：三元组均由三个基分类器组成。 ② 训练集问题。 Adaboost算法目前最有可能实现的Boosting算法是Adaboosting方法，它根据样本的概率分布来挑选训练样本。 与夏皮尔方法相同点：Adaboostng也是逐个创建分类器，每个分类器由不同的训练子集训练得到。 不同点：Adaboosting产生训练子集的方法不同，使用的基分类器更多且无需组成三元组，分类结果不是采用简单投票法而是使用基于权重多数投票机制。 生成训练子集刚开始创建第一个训练子集D1时，每个样本被选取的概率相同，均为p=1/m，并用此子集训练得到第一个分类器h1，然后训练样本被选择的概率将根据分类器h1的结果进行修改。 具体做法为：减小被h1正确分类样本的选择概率(权重)，增加被h1错分样本的选择概率。 在基分类器集成时，采取加权多数表决机制，即加大分类误差小的分类器权重值，使其在表决中起较大的作用，减小分类误差大的分类器权重值，使其在表决中起较小的作用。 概率(权重值)更新的过程为： 令H（x)=∑αi hi(x) 其中H(x)为集成后的分类器，hi(x)为基分类器，α为hi的系数，表示hi(x)在集成分类器中的重要性（权重）。显然H(x)为一加法模型 Adaboost算法（待更） Adaboost实例（待更） 参考资料【1】中科大张曙老师机器学习课程 【2】 统计学习方法","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"机器学习总结（六）支持向量机SVM","slug":"机器学习总结（六）支持向量机SVM","date":"2019-01-14T11:37:44.000Z","updated":"2019-01-14T11:42:20.669Z","comments":true,"path":"2019/01/14/机器学习总结（六）支持向量机SVM/","link":"","permalink":"http://yoursite.com/2019/01/14/机器学习总结（六）支持向量机SVM/","excerpt":"","text":"支持向量给定训练样本集: D={(x(1),y(1)),…,(x(m),y(m))}，y(i)∈{-1,1} 分类学习最基本的思想就是基于训练集D，在样本空间中找到一个划分超平面，将不同类别的样本分开。但能将训练样本分开的超平面可能很多，我们应该选哪一个呢？ 在样本空间中，划分超平面可用如下线性公式来描述： wx+b=0 其中：w=(w1,w2,…,wd)为法向量，决定超平面的方向，b为位移项，决定了超平面与原点间的距离。 ∵ 划分超平面可以被法向量w和位移b确定，记为(w,b)。 ∴ 样本空间中任意点x到超平面(w,b)的距离为： 假设超平面（w,b)能将训练样例正确分类，即 存在一些距离超平面最近的样本点，使得等式成立，称这些样本点为支持向量。 如上图所示，实线为分离超平面，虚线是支持向量，支持向量到超平面的距离之和为： 要找到具有最大间隔的划分超平面。就是要使得上式最大，即： 对偶问题为了求解线性可分支持向量机的最优化问题，将它作为原始最优化问题，应用拉格朗日对偶性。通过求解对偶问题，得到原始问题的最优解，这就是线性可分支持向量机的对偶算法。这样做的优点： 一是对偶问题往往更容易求解，二是自然引入核函数，进而推广到非线性分类问题。 定义拉格朗日函数： 根据拉格朗日对称性。原始问题的对偶问题是极大极小问题： （待更） 参考资料【1】中科大张曙老师机器学习课程 【2】 统计学习方法","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"机器学习总结（五）线性回归和逻辑回归","slug":"机器学习总结（五）线性回归和逻辑回归","date":"2019-01-14T11:35:24.000Z","updated":"2019-01-14T11:37:54.987Z","comments":true,"path":"2019/01/14/机器学习总结（五）线性回归和逻辑回归/","link":"","permalink":"http://yoursite.com/2019/01/14/机器学习总结（五）线性回归和逻辑回归/","excerpt":"","text":"线性回归线性模型的基本形式线性模型的定义：根据线性模型，当权重向量w确定后，线性模型也就得以确定，所以问题转化为如何求权重w。 线性回归的目标函数1、最小二乘法 首先考虑单属性的简单情况。 直线模型为：f(x)=wx+b 线性回归的任务是通过学习确定w和b的值，使f(x)=wx+b≈y 要确定w和b的值，关键是如何衡量f(x)和y之间的误差，方差是线性回归任务中最常用的性能度量方法。 （待更） 参考资料【1】中科大张曙老师机器学习课程 【2】 统计学习方法","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"机器学习总结（四）决策树","slug":"机器学习总结（四）决策树","date":"2019-01-12T08:19:57.000Z","updated":"2019-01-15T12:02:52.996Z","comments":true,"path":"2019/01/12/机器学习总结（四）决策树/","link":"","permalink":"http://yoursite.com/2019/01/12/机器学习总结（四）决策树/","excerpt":"","text":"决策树定义决策树是一种树型结构，其中每个结点表示在一个属性上的测试，每个分支代表一个测试输出，每个叶结点代表一种类别。决策树学习采用自顶向下的递归方法，其基本思想是以信息熵为度量，构造一棵熵值下降最快的树，到叶子结点处的熵值为0，此时每个叶结点中的样例均属于同一个类。 用决策树分类，从根节点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点，这时，每一个子结点对应着该特征的一个取值，如此递归地对实例进行测试并分配，直至达到叶结点，最终将实例分到叶结点的类中。 上图是一个决策树示意图，圆和方框分别表示内部结点和叶结点。 ID3决策树算法思路1234567grow(D)取信息量最大的属性at将D划分为若干个子集Di 对每个子集Di if Di中所有样例都属于同一个类别 then 创建一个类标记的叶结点 else grow(Di) 优点：决策树规模小，查询速度快缺点：不一定是最小规模的树，不能处理连续属性值的情况。 信息量若随机变量x的分布为p(x)，则定义x信息量为： 1I(x)= -log2p(x) 若事件X和Y独立，即p(x,y)=p(x)p(y)，x和y的信息量分别为I(x)和I(y)，则x和y同时发生的信息量为：I(x,y)=I(x)+I(y)。 事件发生的概率越小，则所包含的信息量越大，对于确定性的事件(p=1)，则没有任何信息量。 熵1.熵的定义 熵是平均信息量，对随机事件的信息量求期望，得熵的定义为： 对于二点分布的熵，由上式得到： 信息量代表了一个事件的不确定性，熵表示系统的混乱程度。系统中信息量总和越大，则表明这个系统的不确定性就越大。 如图所示，熵在p=0.5处达到最大为1，在p=0或p=1处达到最小为0。 2.条件熵 条件熵H(y|x)表示在事件x发生的前提下y的熵。 令D为训练集，|D|为训练集中的样例数，Di是用属性at(at有n个取值)划分D后的子集，|Di|为子集Di中的样例数。记子集Dik为Di中类别为Ck的样本集合，样本数为| Dik |。 设有K个类Ck，k=1,2…,K，|Ck|为属于类Ck的样本数，有：∑ |Ck|=|D|。 当熵和条件熵的概率由相对频率估算得到时，所对应的熵和条件熵称为经验熵和经验条件熵。 训练集D的经验熵（系统熵）： 属性at对训练集D的经验条件熵为： 3.信息增益(information gain) 信息增益的定义为：G(D,at)=H(D)-H(D|at) 信息增益表示用属性at划分子集后给系统带来的信息量。信息增益越大，说明系统的“纯度”越高，即确定性越大，所以每次划分应选择信息增益最大的属性。 即求：at=argmax{G(D,at)} 例子： 样例 crust-size shape filling-size 类别 e1 big circle small pos e2 small circle small pos e3 big square small neg e4 big triangle small neg e5 big square big pos e6 small square small neg e7 small square big pos e8 big circle big pos ① 计算系统熵H(D) H(D) = -PposlogPpos-PneglogPneg=0.954 ② 计算各属性的条件熵H(D|at) H(D|shape)=0.5 H(D|crust-size)=0.951 H(D|filling-size)=0.607 ③ 计算各属性的信息增益G(D,at) G(D,shape)=0.454 G(D,crust-size)=0.003 G(D,filling-size)=0.347 ∵ max{G(D,at)}=shape ∴算法选属性shape进行划分。 C4.5决策树连续属性处理对于属性值为连续域情况，需对连续属性离散化，最简单的策略是采用二分法(bi-partition)，这也是C4.5决策树算法中采用的机制。(Quinlan,1993)具体方法用x标记连续属性，然后选择一个阈值Θ，创建一个新的布尔属性at， if x&lt;Θ then at=true else at=false 假设m个训练样例中某个属性at的取值不同数为n，按升序对属性at的n个值排序为：at1,at2,…,atn。在每二个相邻值ati和ati+1间定义一个阈值Θi=(ati+ati+1)/2，这样共定义了n-1个阈值。通过计算新创建的布尔属性的信息量，选择信息增益最大的阈值。 这种方法的一个可能问题是计算代价过高。如m=105，d=100，则需定义的Θ数约为：105×100=107，同时还将计算相应的信息量。好在实际应用中，大部分阈值是可以忽略不计的，这将大大降低计算量。 例：at共有13个取值。 原应有12个阈值，实际只需3个。 ① 计算训练集的熵H(D)=0.9957 ② 计算属性的条件熵H(D|Θ) H(D|Θ1)=0.4993 H(D|Θ2)=0.9811 H(D|Θ3)=0.9045 ③ 计算信息增益G(D,Θ) G(D|Θ1)=0.4964 G(D|Θ2)=0.0146 G(D|Θ3)=0.0912 ∵ G(D, Θ1)最大 ∴ 该连续属性选择Θ1作为阈值进行离散，即一个样例该属性的连续值小于Θ1 ，则位于左子树，否则位于右子树。 增益率(gain ratio)用信息增益选择属性进行划分的缺点是太偏好取值数目较多的属性。因为取值较多的属性其信息增益相对较大，但泛化能力则弱。为避免不足，C4.5算法采用增益率作为属性划分的准则。 信息增益率的定义为： 其中IV（at）称为分裂信息量 属性值at的可能取值数目越多（即n越大），则IV（at)的值越大，由此看出，增益率准则对可取数较小的属性有偏好。但C4.5算法并不是直接选择增益率最大的属性进行划分，而是从增益率高于平均值的属性中选择增益率最大的属性。 决策树过拟合解决剪枝剪枝是决策树学习方法解决过拟合问题的重要手段。在决策树学习中，为了尽可能正确分类训练样本，结点划分过程将不断重复，这样有时会造成决策树分枝过多。这种因对训练样例学得过好，而把训练集自身的一些特点当作所有数据都具有的一般性质而导致过拟合。因此通过主动去掉一些分枝来降低过拟合的风险。 剪枝的方法就是用叶结点替换子树。 剪枝后原决策树的规模将减小，引起一些训练样例错误分类，影响模型的精度或正确率。但这个问题并不严重，因为我们关心的是模型的泛化能力，而不是对已知训练样例100%的正确率。 ① 误差估计 令n是到达测试结点ti的训练样本数，当用叶结点替换ti为根的子树后，n个样例中将有一些样例被错分。用e来表示这些错误分类的样例数，用相对频率e/n来估算一个样例在这个叶结点上被错误分类的概率： 修正项是为了避免n过校引起的问题，则整棵树的错误率可以通过所有剪枝后各子树的错误率加权平均得到。 如上图中，令n2和n5分别为到大t2和t5的训练样例数，令E2和E5为两棵子树的错误率，则树的错误率为 预剪枝预剪枝是在决策树生成过程中，对每个结点在划分前先进行估算。若当前结点的划分不能带来决策树泛化能力的提升，则停止划分并将当前结点标记为叶结点。 预剪枝过程： 首先基于信息增益率法则选择属性t1对训练集样例划分，并产生t2和t5子结点。若不需要划分则t1标记为叶结点，其类别为样例数最多的类别。接着用测试集的样本对决策树进行评估。评估用t1划分后测试集的准确率，若划分后的准确率高于划分前，则完成本次划分，反之则不划分。 后剪枝后剪枝先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点考察，若将该结点对应的子树替换为叶结点能提升决策树的泛化能力，则完成剪枝。 后剪枝过程： 首先用测试集计算决策树的准确率，然后从最底层非叶结点子树替换为叶结点，计算剪枝后的准确率，若剪枝后准确率提升，则完成剪枝，反之则不进行剪枝。这样的剪枝过程自底向上直到根结点为止。 总结： 因为对树的剪枝方案有很多，选择什么剪枝方案可以应用误差估算的方法来决定。即根据剪枝前后的误差来估算：D=Eafter-Ebefore 通过计算所有剪枝方案的D值，选取最小的D值剪枝方案，并检查Dmin≤C，其中C为用户设定的阈值，只有满足条件才进行剪枝。重复以上过程，直到没有剪枝方案为止。 CART决策树即CART（classification and regression tree)决策树。 CART算法最早由Breiman等1984年提出。 决策树的生成就是递归构建二叉决策树的过程，对回归树用平方误差最小化准则，对分类树用基尼指数最小化准则进行特征选择。 即CART算法由以下两步组成： （1）决策树的生成：基于训练数据集生成决策树，生成的决策树要尽可能的大。 （2）决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准。 CART分类树算法在选择划分时，不是采用信息增益或者增益率，而是基尼指数。 决策树的生成回归树的生成 分类树的生成分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。 基尼指数： 其中pk是第Ck类的概率，Ck是D中属于第k类的样本子集，K是类的个数。 CART算法在候选属性几何中选择使划分后基尼指数最小的属性作为最优划分属性，即： 如果样本集合D根据特征A是否取某一可能值a被分割成D1和D2两部分，即 则在特征A的条件下，集合D的基尼指数定义为： CART生成算法： CART剪枝CART剪枝从一棵完整的决策树的底部开始剪去一些子树，使决策树变小，从而能够对未知数据有更准确的预测。 剪枝由两步组成：首先从生成算法产生的决策树T底端开始不断剪枝，直到T的根结点，形成一个子树序列{T0,T1,…,Tn}；第二步通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。 参考资料【1】中科大张曙老师机器学习课程 【2】 统计学习方法","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"实用算法总结（五）查找（字符串匹配算法KMP、BM）","slug":"实用算法总结（五）查找（字符串匹配算法KMP、BM）","date":"2019-01-08T06:04:11.000Z","updated":"2019-01-08T06:05:02.929Z","comments":true,"path":"2019/01/08/实用算法总结（五）查找（字符串匹配算法KMP、BM）/","link":"","permalink":"http://yoursite.com/2019/01/08/实用算法总结（五）查找（字符串匹配算法KMP、BM）/","excerpt":"","text":"字符串：由零个或多个字符组成的有限序列。 字符串s=”a1a2…an”(n≥0) 串的长度：串中的字符数目n 空串：零个字符的串。即串的长度为0. 空格串：只包含空格的串。 逻辑结构：可认为是特殊的线性表。串中的元素只能是字符类型。 线性表：关注单个元素的操作 字符串：关注子串的操作：查找/插入/删除/替换子串. 存储结构：推荐顺序存储方式。 例如，存储串”good”，需要5个字节，但是其长度为4。 字符串查找场景： 例如，在文本“fffffab cfe defe”中查找字符串“ff” 本质：在字符线性表（主串或目标字符串T）中查找匹配的子表（子串或模式字符串P）。 字符串查找（或模式匹配）算法： 朴素的模式匹配算法、KMP算法（Knuth-Morris-Pratt)、BM算法（Boyer-Moore) 朴素的模式匹配算法 假设目标串T长度为n，模式串P长度为m.假定T中确实存在子串P（即假定模式匹配成功），则： 最好的情况下的近似时间复杂度为O(m)比如，在”googlegood”中查找”google”. 若每次不成功的匹配都发生在串P的首字符处，则平均情况下的近似时间复杂度为O(n+m) 最坏的情况下的近似时间复杂度为O((n-m+1)*m).比如，在“000…00001”中查找“0001”. 朴素的模式匹配算法：需要进行回溯 字符串查找算法中，最著名的两个算法： KMP算法（Knuth-Morris-Pratt)和BM算法（Boyer-Moore) 它们都是精确字符串匹配算法（区别于模糊匹配）。 目标字符串中无需进行回溯。（都比朴素的模式匹配算法快） 模式字符串的移动方向：从目标字符串的第一个字符开始，朝 目标字符串的尾部方向移动搜索匹配子串。 匹配操作的方向： KMP算法：每轮匹配时，采用从左向右进行字符的匹配比较。 BM算法：每轮匹配时，采用从右向左进行字符的匹配比较。 KMP算法KMP算法的主要思想将模式串P自身的重复规律保存到next数组中 匹配过程：若某轮匹配失败，则利用next数组分别计算下一轮匹配时目标串和模式串的开始位置。 若是T[i]≠P[j]导致当前轮的匹配失败，则按照下列规则开始下一轮匹配： 若next[j] ≠ 0，则将T[i..]与P[next[j]..]匹配； 若next[j]==0，则将T[(i+1)..]与P[1..]匹配 。 注意：在KMP算法中，模式串P的下标从1开始 next数组的计算示例 KMP算法的改进 KMP算法什么情况下有改进的空间？ &emsp;假设T[i] ≠P[j]导致失配。若P[j]==P[next[j]]，此时若向右移动模式串P，将T[i]与P[next[j]]对齐进行比较必然是无意义的，因为此时T[i]必定≠P[next[j]]。 如何改进？ &emsp;用nextval数组代替next数组。 &emsp;nextval[1]=0; &emsp;for(j&gt;1;j&lt;=n;j++) &emsp;&emsp;&emsp;若P[j] == P[next[j]]，则==nextval[j]=nextval[next[j]];==（易错，是nextvall[next[j]],不是next[next[j]]） &emsp;&emsp;&emsp;若P[j]≠P[next[j]]，则nextval[j]=next[j]; &emsp;若某轮匹配失败，则利用nextval数组计算下一轮匹配时的目标串和模式串的开始位置（类似next数组的应用） nextval数组计算示例 nextval数组的应用： 例：在目标串“aaaaaaacaaaaaaaab”中查找模式串“aaaaaaaab”的位置。Step1：计算模式串的next数组： Step2：匹配过程。（2轮） KMP和朴素模式匹配的比较 KMP近似时间复杂度为O(n+m),其中O(n)表示比较的时间，O(m)表示计算next数组的时间. 目标串中不存在回溯情况 目标串中的每个字符，会比较1~2次； 仅当模式串与目标串之间存在许多“部分匹配（重复模式）”情况下，KMP算法才比朴素模式匹配算法更具优势。 若每轮中模式串与目标串之间的不匹配都发生在模式串的第一个字符处，则KMP算法会退化到朴素模式匹配算法。因为nextval[1]=0; BM算法（Boyer-Moore)BM算法是字符串查找算法中最著名的两个算法之一。是一种精确字符串匹配算法（区别于模糊匹配）。 每轮匹配过程中，字符的匹配方向：采用从右向左进行字符的匹配比较。（与KMP算法的主要区别） 若某轮匹配失败，则移动模式串，与目标串的下一轮开始匹配位置进行右对齐，然后开始下一轮的字符匹配。 故，BM算法中的关键问题是，如何确定目标串中的下一轮匹配的开始位置？即，如何确定目标串中查找指针的移动距离？ 采用启发式方法：无需检查目标字符串中的所有字符 算法基本思想设目标串T，模式串为P。 Step1：对于模式串P，计算CharJump[x]和MatchJump[k]。 Step2: 将T与P进行左对齐。 Step3: T与P进行从右向左的逐字符比较 ，直至找到一个不匹配字符或者P中所有字符都匹配成功。 Step4: 若出现失配，即存在T[i]≠P[k]，此时坏字符x=T[i]，好后缀P’=P[(k+1) … (len(P)-1)]。 按如下规则计算 目标串T中指针向右移动dist[i]：若此时T与P已有部分字符匹配（即存在“好后缀” ）时，BM算法将采用2种启发式方法（即坏字符规则 和好后缀规则 ），计算dist[i] =max(CharJump[x], MatchJump[k])。 若不存在“好后缀”，则必定是在模式串P的最后一个字符处出现失配。此时应采用启发式方法1： 跳过字符规则（“坏字符”规则），计算设置dist[i] =CharJump[x]。 Step5: 若(i+dist[i])≤Len(T)-1，则移动模式字符串P，使之与T[i+dist[i]]右对齐，重复Step2；否则，认为T中不存在与P匹配的子串，返回匹配失败。 “坏字符规则”“坏字符”规则：假设坏字符为x=T[i]， Case1：如果坏字符x在模式P中没有出现，那么从字符x开始的Len(P)个字符显然不可能与P匹配成功，因此，可以使目标串中查找指针直接跳过Len(P) 个字符。 Case2：如果坏字符x在模式P中出现(假设P[j]==x)，则下一轮匹配开始时以字符P[j]进行对齐，即将目标串中查找指针移动CharJump[x]. 关键问题：计算CharJump[x] 若x在P中出现，假设p[j]==x，则CharJump[x]=Len(P)-max(j)-1; 否则， CharJump[x]=Len(P); 例：若模式串为”abcd”，则 CharJump[‘a’]=3 CharJump[‘b’]=2 CharJump[‘c’]=1 CharJump[‘d’]=0 CharJump[all others]=4 例：若模式串为”abcadb”，则 CharJump[‘a’]=2 CharJump[‘b’]=0 CharJump[‘c’]=3 CharJump[‘d’]=1 CharJump[all others]=6 坏字符规则存在的问题： 例：在“ecbcabebacab”中查找子串“ebacab”的位置。 左对齐，失配的是第三个字符’b’。charjupm[‘b’]=0,移动距离=0（此时指针移动距离是无效值） 若利用“坏字符”规则，目标串中查找指针的移动距离dist=0，那么此时失配处必定不是在模式串的最后一个字符处，即此时必定存在“好后缀”。 可以利用好后缀规则进行修正，让指针动起来。 “好后缀”规则（待续） 参考资料【1】中科大余艳玮老师实用算法课程 【2】《编程珠玑(第2版)修订版》","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"实用算法总结(四）查找（哈希、蛮力、二分）","slug":"实用算法总结(四）查找（哈希、蛮力、二分）","date":"2019-01-08T05:27:44.000Z","updated":"2019-01-08T06:01:51.475Z","comments":true,"path":"2019/01/08/实用算法总结(四）查找（哈希、蛮力、二分）/","link":"","permalink":"http://yoursite.com/2019/01/08/实用算法总结(四）查找（哈希、蛮力、二分）/","excerpt":"","text":"本文总结了查找算法，顺序是基于哈希表的查找、蛮力查找、二分查找 基于哈希表的查找Step1: 查找“槽” ： HashKey = H (key) Step2: 在每个槽上挂的线性表上查找 案例1统计出给定输入文本中每个单词的重复次数。 解题思路： 使用哈希表，使得相同单词聚集，统计次数。 案例2给定一个英语词典。假设有一些时间和空间可以在响应任何查询之前预先处理词典。请查找给定输入单词的所有变位词。例如，”pots”、”stop”和”tops”互为变位词。（编程珠玑第二章以及习题2.1） 解题思路： 标识+二分查找 标识字典中每一个词，使得在相同的变位词类中的单词有相同的标识，然后，将所有具有相同标识的单词集中在一起。因此，原始的变位词问题就简化为两个子问题：选择标识和集中具有相同标识的单词。 上图的步骤： 1、选择标识/签名（sign) 选择标识，可以使用基于排序的标识，将单词中的字母按照字母表顺序排列，比如“deposit”的标识就是”deiopst”,这也是”deiopst”和所有在该类的单词的标识。 2、集中具有相同标识的单词/排序(sort) 利用hash表来集中具有相同标识的单词（+hash表查找） 将所有的单词按照其标识的顺序排序。 3、挤压（squash)将这些单词压缩为每个变位词类一行的形式 案例3在成本低廉的隔日送达时代之前，商店允许顾客通过电话订购商品，并在几天后上门自取。商店的数据库使用客户的电话号码作为其检索的关键字（客户知道他们自己的电话号码，而且这些关键字几乎都是唯一的）。你如何组织商店的数据库，以允许高效的插入和检索操作？ 解题思路： 商店将纸质订单表格放在10 10的箱数组中，使用客户电话号码的最后两位作为散列索引（每一位可以0-9个数字，两位数共有10 10=100个取值可能）。当客户打电话下订单时，将订单根据电话号码最后两位放到适当的箱子中，当客户来取商品时，在对应的箱子中顺序查找。（这就是经典的“用顺序搜索来解决冲突的开放散列”) 电话号码最后两位数字非常接近于随机，因此是比较理想的散列函数，而最前面的两位数字则很不理想，为什么？ 这个很好理解，大部分电话号码第一位都是1，后面紧跟着运营商、城市等等，比如有很多156、183等等开头的电话号码，这样就造成大量的电话号码放在相同的箱子里，其他箱子很多都是空的，查找效率很低。 案例420世纪70年代末期，贝尔实验室开发出了“用户操作的电话号码簿辅助程序”，该程序允许雇员使用标准的按键电话在公司电话号码簿中查找电话号码。比如，要查找该系统的设计者 “Mike Lesk”的电话，则按“LESKM”（也就是“53756”），随后，系统会输出他的电话号码。这样的服务现在随时可见。但是，该系统中出现的一个问题是，不同的名字可能具有相同的按键编码。在这个Lesk系统中，系统会询问用户更多的信息。如何实现一个以名字的按键编码为参数，并返回所有可能的匹配名字的函数？ 解题思路： 用按键编码标识每个名字，并根据标识排序（当标识相同时候用名字排序）。为了检索出给定按键编码的名字，可以使用一种包含标识和其他数据的结构。尽管我们可以对该结构排序，然后使用二分搜索查询按键编码。实际系统往往使用散列技术或者数据库系统。 案例5来自：《编程珠玑》13.8节——如何表示字典 Doug McIlroy于1978年写的Spell程序。 问题定义：如何用64KB的空间存储30,000个单词，并能实现较准确的、快速的拼写错误检查。 解题思路： 方法一：利用大小为5的Hash表存储“a list of five words” 这种散列方法用到了一个几乎和单词列表一样大的n元散列表以及把字符串映射为[0,n)范围的整数的散列函数。表的第i项指向一个链表，该链表包含所有散列到i的字符串。 如果要查找单词w，对第h(w)个单元指向的链表进行顺序搜索。 方法二：利用大小为37的Hash表存储“a list of five words” 这种方法，几乎所有的非空链表上仅包含一个元素。 方法三：仅存储非空槽的槽号，则存储空间为5*ceil(log223)=25bit! 为了查找单词w,程序访问表中的h(w)位，如果该位为0.就会正确报告该单词不在表中，如果该位为1，就认为w在表中，但是有时候不正确的单词会碰巧散列到有效位置，这种错误概率较小。 程序仅仅表示值为1的位，比如上图，存储散列值：5 10 13 18 22 案例6给定一个输入的整数，要求从1000万个整数中找出满足以下条件的所有数：这些数模256后的结果值等于输入的指定数模256后的结果值。进一步地，如果原集合中存在输入的指定数，则把这个数从集合中删除，否则把这个数加入集合。 解题思路：（暂略） 案例7《编程珠玑》P134-135 问题描述：有序输出取值范围为0-99的20个不重复的随机整数。 提示：采用箱数组，每个箱用一个有序链表表示。映射规则：箱0包含0-24范围内的整数；箱1包含25-49范围内的整数；箱2包含50-74范围内的整数；箱3包含75-99范围内的整数； 问题定义：将0-99之间的整数，放在合适的箱中。 基于蛮力的查找算法思路int BruteSearch(List MyArray, ElemType SearTarg)： 输入：线性表MyArray，要查找的目标项目SearTarg 输出：若查找失败，则输出-1；若查找成功，则输出匹配项的位置。 算法设计思路： Step1: 从线性表MyArray中的第一个元素开始，与目标项进行比较，若匹配，则输出匹配项的位置；否则移动到下一个元素继续比较，直至找到匹配项。 Step2: 若线性表中所有元素都已比较到，但是仍未找到匹配项。则认为查找失败，输出-1。 伪代码示例1234567int BruteSearch(List MyArray, ElemType SearTarg)&#123; for i=[0,n) if (MyArray[i] == SearTarg) return i; return -1;&#125; 蛮力查找优化1优化点：在数组末尾放置一个哨兵值 好处：在循环过程中无需检测是否已到数组末尾。大约加速了5% 伪代码：12345678910111213int BruteSearch1(List MyArray, ElemType SearTarg)&#123; hold= MyArray[n]; MyArray[n]= SearTarg; for (i=0; ;i++) if (MyArray[i] == SearTarg) break; MyArray[n]= hold; if i==n return -1; else return i; &#125; 最内层循环只包含一次自增、一次数组访问以及一次匹配判断。还可以进一步优化吗？ 蛮力查找优化2优化点：将循环展开8次来并行执行（每8次的探查中，才自增1次，自增量取决于元素的匹配判断结果） 好处：将循环展开有助于增加指令的并行性。 伪代码： 123456789101112131415161718int BruteSearch1(List MyArray, ElemType SearTarg)&#123; MyArray[n]= SearTarg; for (i=0; ;i+=8)&#123; if (MyArray[i] == SearTarg) &#123; break; &#125; if (MyArray[i+1] == SearTarg) &#123; i + =1; break; &#125; if (MyArray[i+2] == SearTarg) &#123; i + =2; break; &#125; if (MyArray[i+3] == SearTarg) &#123; i + =3; break; &#125; if (MyArray[i+4] == SearTarg) &#123; i + =4; break; &#125; if (MyArray[i+5] == SearTarg) &#123; i + =5; break; &#125; if (MyArray[i+6] == SearTarg) &#123; i + =6; break; &#125; if (MyArray[i+7] == SearTarg) &#123; i + =7; break; &#125; if i==n return -1; else return i; &#125;&#125; 字符串查找场景中的蛮力查找优化12345678910char * BruteSearch ( const char *text, const char *string )&#123; int len = strlen ( string ); for ( ; *text; text++ ) if ( strncmp ( text, string, len ) == 0 ) return ( (char *) text ); return ( NULL );&#125; 这种蛮力查找方法简单而缓慢，可以考虑如下几种方式优化： 方案1 &emsp;仅当字符串的第一个字符发生匹配时，才需要调用strncmp()函数； &emsp;但是，仍需对字符串的第一个字符至少执行两次比较：判断字符是否匹配；判断是否到文本的结尾处 方案2： &emsp;使用switch语句，实现一个跳转表，那么只需比较一次即可。&emsp;但是，C语言中的字符串不允许使用case进行评估。 方案3：能否自己实现一个映射，以实现case评估支持呢？（略） 基于有序表的二分查找实例引入问题：给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。 在文件中必然缺失一个这样的数，为什么？ 一共有2^32=4294967296个这样的数，顺序文件里面只包含40亿，因此一定有整数不在文件中。 在具有足够内存的情况下，如何解决该问题？ 有足够的内存，可以用位图法。 如果有几个外部的“临时”文件可用，但是仅有几百字节的内存，又该如何解决？ 主要思路：找到中间点，二分 举个栗子，思想是一样的： 假设数组x中元素取值范围为[3,10] Case 1:x中包含n=4个元素 探测到中间点x[i]=6所在的位置。 大于中间点的元素有1个（&lt;预期值4） 小于等于中间点的元素有3个（&lt;预期值4） 因而数组x的左半部分区间和右半部分区间一定都缺失了元素。（大规模问题 =&gt; 小规模问题） Case 2:x中包含n=6个元素 探测到中间点x[i]=6所在的位置 大于中间点的元素有2个（&lt;预期值4） 小于等于中间点的元素有4个（=预期值4）因而数组x的右半部分区间一定缺失了元素。（大规模问题=&gt;小规模问题） 注意：由于数组x中实际元素数目&lt;理论上的数目，故总可以找到一个区间缺失了元素，且该区间的范围可以逐渐缩减。 二分查找基本思想int BinarySearch(DataType t)： 功能描述：在升序排列的线性表x中查找t出现的位置。 输入：要查找的目标项目t 输出：若查找失败，则输出-1；若查找成功，则输出匹配项的位置。算法设计思路： Step1: 设置查找区间为[0,n-1] Step2: 若查找区间是合法的（下界&lt;上界），则比较线性表x中查找区 间内的中间元素x[n-1/2]与t，并进行相应处理 若中间元素x[n-1/2] &lt;t，则将查找区间变为[(n-1)/2,n-1]，并重复Step2； 若中间元素x[n-1/2] &gt; t，则将查找区间变为[0, (n-1)/2] ，并重复Step2 ； 若中间元素x[n-1/2]==t，则表示成功匹配，并输出匹配项的位置，退出程序。 Step3: 查找失败，输出-1。 怎么写一个正确的二分程序？以及怎么用脚手架测试二分程序的正确性？怎么优化？（待续） 参考资料【1】中科大余艳玮老师实用算法课程 【2】《编程珠玑(第2版)修订版》","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"机器学习总结（三）朴素贝叶斯","slug":"机器学习总结（三）朴素贝叶斯","date":"2019-01-08T04:37:54.000Z","updated":"2019-01-15T09:50:36.162Z","comments":true,"path":"2019/01/08/机器学习总结（三）朴素贝叶斯/","link":"","permalink":"http://yoursite.com/2019/01/08/机器学习总结（三）朴素贝叶斯/","excerpt":"","text":"朴素贝叶斯假设令x=(x1,x2,…,xd)为d维属性向量，C=(c1,c2,…,ck)，其中ci表示第i个类的标记，则贝叶斯公式为： ∵ 每个公式中每个ci的条件概率分母一样 ∴ 实际计算时只需考虑分子的大小 在公式中,P(ci)很容易从训练集中得到，P(x|ci)表示从ci类中随机挑选一个样例其属性向量为x的概率，那么这个概率值能否如单属性情况用相对频率来估算？ 如果属性之间是相互独立的，即朴素贝叶斯假设，则此时P(x|cj)的计算公式为： 其中P(xi|cj)表示类别cj中样例x取第i个属性的概率，由此得到朴素贝叶斯概率为： 问题：属性之间不是相互独立的怎么办？ 事实上在很多实际应用中，属性之间存在关系，如物体重量与体积，年龄与出生日期等。 case1: 可以忽略影响 虽然违背了朴素贝叶斯假设的独立性要求，导致概率值的不准确，但很多时候并不影响分类的结果。 case2: 不能忽略影响时，计算P(x|cj)可采取的办法有： ① 采用更加复杂的公式或方法 ② 去除冗余的属性 ③ 用一个新的属性替换相关联的属性 ④ 采用其他分类方法 朴素贝叶斯分类算法1234567Bayesian-classification(x,C) for each(xi) and each(cj) do 计算 P(xi|cj) for each(cj) do 计算 P(cj) P(x|cj)=∏P(xi|cj) return max&#123;P(cj)×P(x|cj)&#125; 基于朴素贝叶斯分类器算法比较简单，且模型所需参数很少，在属性个数较少或关联性较小时，利用朴素贝叶斯算法分类效果较好，且误差比决策树模型更小。 问题1：对于条件概率P(x|cj)，由于涉及到关于x的所有属性的联合概率，尽管我们假设属性之间是相互独立的，但直接根据样本出现的频率来估算概率实际会遇到很大困难。 假设样本空间的d个属性都是二值的，则样本空间将有2^d种可能的取值，远大于样本数m。如派的例子，包含12个样例，实际属性值组合共有3 × 2 × 3 × 2 × 3=108，每个属性值对应了一个样例，所以样本空间共有108个样例，即还有108-12个样例是缺失的。当用相对频率来估算概率时，将出现P(x|cj)=0。 解决办法：平滑处理常用拉普拉斯修正(Laplacian correction)。令k表示训练集D中的类别数，ni表示第i个属性的可能取值数，则： 问题2：稀少事件的概率估算用相对频率估算概率值的方法，只有在大量样本(实验)的支持下才可以被信任。 解决方法：使用m-估值 以抛硬币正面朝上的概率m-估算： P(head)=(Nhead +mπhead)/(Nall+m) 其中Nall为抛硬币次数，Nhead为正面朝上的次数，πhead为正面朝上的先验概率，m为估值参数 若Nall=Nhead=0，则公式退化为先验概率 若Nall，Nhead足够大时，mπhead和m项可忽略不计，公式将收敛为相对频率。 例：假设πhead=0.5，m=2 案例计算(统计学习方法第四章案例) 因此 Y=-1 例子：上题，按照拉普拉斯估计概率，计算结果： 因此Y=-1 连续属性情况在许多实际应用中，属性的取值是从连续域中取值的，再想用相对频率来估算概率值就不现实了，因为连续域中取值可以有无穷多个，每个值的概率都趋于无穷小。 离散化方法把连续域划分为多个区间进行离散化。如原始域为(10,100)可离散化为区间：(0,10],(10,20],…,(90,100)，每个区间分别用b1,b2,…,b10表示。 由此可以计算每个区间的相对频率来估算落入区间的概率值|Di|/|D|。 概率密度函数由上图的阶梯函数通过计算区间的面积可以估算落入该区间的概率，但阶梯函数过于粗糙，更好的方法是用概率密度函数。如果把区间不断细分直到每个区间变为无限小，则阶梯函数将变为一个连续函数，即概率密度函数p(x)。 ① 连续属性的贝叶斯公式 p(ci|x)=p(x|ci)P(ci)/p(x) 其中：P(ci)由训练集中第ci类的相对频率估算 p(x)是从所有训练集样本中得到的概率密度函数 p(x|ci)是从训练集中属于第ci类的样本中得到的概率密度函数，在属性之间相互独立的假设下，在x处的概率密度函数为： ② 高斯钟形函数 许多实际问题均服从正态分布(高斯分布)，所以一种近似计算概率密度函数方法为高斯函数。 参考资料【1】中科大张曙老师机器学习课程 【2】 统计学习方法","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"机器学习总结（二）k近邻法","slug":"机器学习总结（二）k近邻法","date":"2019-01-07T12:58:26.000Z","updated":"2019-01-15T09:05:37.158Z","comments":true,"path":"2019/01/07/机器学习总结（二）k近邻法/","link":"","permalink":"http://yoursite.com/2019/01/07/机器学习总结（二）k近邻法/","excerpt":"","text":"基本原理k近邻是一种基本分类和回归方法，其工作机制非常简单：基于某种距离度量找出训练集中与其最靠近的k个训练样例，然后基于这k个邻居的信息进行预测或分类。通常在分类任务中使用投票法，在回归任务中使用平均法，也可根据距离远近进行加权平均或加权投票。 kNN是一种称为懒惰学习方法，它没有明显的训练(学习)过程，在训练阶段仅仅是保存样本，因此训练开销为0。 三要素：k值选择、距离度量、分类决策规则 当训练集、k值、距离度量及分类决策规则确定后，对于任何新的输入样例，它所属的类别将唯一确定。这相当于根据上述要素将特征空间划分为一些子空间，确定子空间里每个点所属的类。 特征空间中，对每个训练样例xi，所有距离该点更近的点组成一个区域，称为单元(cell)。最邻近法将样例xi的类别yi作为其单元内所有点的类标记，这样每个单元样例点的类别是确定的。 距离度量特征空间中二个样例点的距离是二个样例相似程度的反映。kNN特征空间一般是d维的实数空间，使用的距离为欧氏距离，但也可以是其他距离。 欧式距离： k值的选择k值选择对kNN方法的结果产生重大影响。如果选择较小的k值，相当于用较小范围内的训练样例进行预测，因此只有较近的训练样例才会对预测结果起作用。缺点是预测结果对近邻的训练样例非常敏感，如果恰巧是噪声，则预测将会出错。换句话说，k值的减少意味着整体模型变得复杂，容易引起过拟合。 如果选择较大的k值，相对于用较大范围内的训练样例进行预测。优点是可以减少学习误差，缺点是与输入样本较远的(不相似)的训练样例也会对预测起作用，使预测出错。 k值增加意味着模型变得简单。特别地，如果k=m，那么无论输入是什么，测试结果都取训练集中最多类的标记，显然不可取。在实际应用中，k值一般取一个较小的数值，通常为奇数，或采用交叉验证法来选取最优的k值。 分类决策规则kNN法中分类决策规则往往采用多数(投票)表决，即由输入样例的k个近邻类别多数所决定。 构造kd树实现kNN时，主要考虑的问题是如何对训练数据进行快速k近邻搜索，这对于特征空间的维数及训练集很大时尤为重要。 kNN法最简单的实现方式为线性扫描，这时要计算预测样例与每一个训练样例之间的距离，当训练集很大时，计算非常耗时，实际不可行。 应用kd树结构可以减少计算距离的次数，从而达到k近邻搜索的效率。 构造kd树kd树是一种对k维空间中样例点的存储方式,可以对其进行快速检索的二叉树结构。构造kd树相对于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每个结点对应于一个k维超矩形区域。 构造kd树的方法为： 首先创建根结点，使根结点对应于k维空间中包含所有训练样例的超矩形区域，然后在这超矩形区域上选择一个坐标轴(属性)和在此坐标轴上的一个切分点,确定一个超平面。 这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右二个子区域(子结点)。 递归划分过程，直到子区域内没有训练样例时终止，终止时的结点为叶结点。 通常划分空间的切分点可选择训练样例点在选定坐标轴上的中位数(中间位置的一个数或最中间二个数的平均值)，这样得到的kd树为平衡的kd树，但平衡的kd树在搜索时的效率未必是最优的。 构造平衡kd树算法输入：k维空间训练集D={x1,x2,…,xm}，其中xi=(x1(i),x2(i),…,xd(i)) 输出：kd树 过程： 创建根结点，对应于包含D的k维空间的超矩形区域 选择x1(x的第一个属性)为坐标轴，以D中所有样例的x1坐标的中位数为切分点，将根结点对应的超矩形区域切分为二个子区域。切分由通过切分点并垂直于坐标轴x1的超平面实现。 生成左右二个子结点，左子结点对应于坐标x1小于切分点的子区域，右子结点对应于坐标x1大于切分点的子区域，将落在切分超平面上的训练数据点保存在根结点上。 递归划分过程，直至子区域没有样例点为止。 例：构造平衡的kd树 kd树kNN搜索以最近邻(k=1)为例，同样的方法可以应用到kNN。 kd树最近邻算法如下： 输入：已建立的kd树，目标样例为x 输出：x的最近邻 过程： 在kd树中找出包含目标点x的叶结点：从根结点走到相应的叶结点 以叶结点为当前最近邻，递归向上回退，在每个结点进行如下操作： if该结点保存的样例点比当前最近邻距离更近，则以该训练样例点为最近邻。 当前最近邻点一定存在于该结点一个子结点对应的区域，检查该子结点父结点的另一个子结点对应的区域是否有更近的点。具体来说，检查另一子结点对应的区域是否与目标点为球心，目标点与当前最近邻的距离为半径的球体相交：如果相交，则以该区域递归最近邻搜索，否则向上回退。 当回退到树根结点时，搜索终止，当前最近邻点即为x的最近邻点。 例题：给定如图所示的kd树，根结点为A，其子结点为B、C等。树上共存储了7个训练样例点，S为输入值，求S的最近邻。（答案是E) 加权最近邻引入加权投票机制更加合理：即为每个近邻点赋予一个权重，距离近的权重大一点，距离远的权重小一点。 令w1,w2,…,wk为k个近邻的权重，加权k近邻分类器把正类近邻的权重和负类近邻的权重比较，输出相应的结果。 假设k个近邻点按照距离大小排列为：d1,d2,…,dk 其中d1最小，dk最大，则一个简单计算第i个近邻权重公式为： 可能存在的问题1、不相关属性的影响 如属性包含体温、鞋号，对于预测是否发烧等 2、属性值的尺度影响 如有二个样例分别为x1=（0.2，254）和x2=（0.1，194） 解决办法：标准化属性尺度x=(x-min)/(max-min) 3、危险样例 由于在训练集中存在一些噪声或影响分类性能的样例，所以在使用训练集之前需要进行预处理，删除那些被认为是无效或有害的样例。其他分类器也有类似的问题。 需要预处理的二种情况： ● 某个样例被其他类别的样例所包围 ● 二个类边界区域的样例 托梅克(Tomck)连接技术 在移除危险样例前，首先要能检测到这些危险的样例。可以使用托梅克连接技术。具体为： 一个样例对x1和x2，如果同时满足3个条件，则它们形成了一个托梅克连接。 ① x1是x2的最近邻 ② x2是x1的最近邻 ③ x1和x2类别不同 需要注意的是移除一个托梅克连接可能会生成新的托梅克连接，所以需重复执行多次。 删除托梅克连接存在的问题 ① 并不能检测到所有导致错误的样例，相反可能使一些无辜的样例被删除 ② 训练集样例比较少时 ③ 当一类样例数明显少于另一类样例数时 参考资料【1】中科大张曙老师机器学习课程 【2】 统计学习方法","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"实用算法总结（三）哈希表","slug":"实用算法总结（三）哈希表","date":"2019-01-03T09:58:19.000Z","updated":"2019-01-03T10:35:31.399Z","comments":true,"path":"2019/01/03/实用算法总结（三）哈希表/","link":"","permalink":"http://yoursite.com/2019/01/03/实用算法总结（三）哈希表/","excerpt":"","text":"哈希表的定义Hash表（哈希表）是一种线性结构。是有限个数据项组成的序列，记作(a1,a2, … , an) Hash表（哈希表）可以建立数据项的关键字和其逻辑存储位置之间的对应关系。即：HashKey = H (key) Key（关键字）：是数据项（或记录）中某个分量的值，它可以用来标识一个数据元素（或记录）。 主关键字：唯一标识一个记录的关键字 HashKey （hash键 ）：也称为槽。它是关键字的“像”，是关键字在该表中的逻辑存储位置。 （必须合法，∈ [0,hash表长-1]） H（Hash函数）：是一个映像，它将一组关键字映像到一个有限的、地址连续的地址区间上。（h : Key -&gt; HashKey）。 Hash表的构造过程，是将关键字映像到其逻辑存储位置（或hash键 ）的过程。 冲突：两个不同的数据项映像到同一个HashKey上。即： Key1≠Key2，但H(Key1)= H(Key2)。 基本哈希表的实现：利用动态定义的顺序表来实现基本hash表。 1234567#define Table_Size 100/*分配空间的大小*/Typedef HashTable_Struct&#123; ElemType *elem; /*顺序表的存储空间*/ int len; /*实际长度*/ int TableSize ; /*当前分配的空间大小*/&#125;;typedef struct HashTable_Struct HashTable; Hash表的适用场景： 要求在内存中存储具有线性结构的数据集合 集合中的数据项的数量预先无法确定 要求能快速、近似随机的访问数据项 哈希表的构造散列函数的通用形式： Hashkey = calculated-key(key) % Table_Size 完美散列函数：不同数据项，对应的HashKey也不同。（永远不会出现冲突）。 实际：几乎不可能构造出完全散列函数，因此应选择良好的通用算法。 良好的散列函数：HashPJW, ElfHash 1）计算快速，Hashkey分布均匀; 2）必须弥补可能出现在输入数据中的聚集。 哈希表冲突解决方法线性再散列法di(增量序列)是线性的，可以是1，3，5等与表大小互质的数即可。互质可以保证表中的每个槽都会被检查到。 思想：从冲突位置开始，以顺序方式遍历散列表，来查找一个可用的槽。 可能有3种结果： 1）该元素已经在hash表中了； 2）找到一个空槽； 3）hash表满了。 缺点： 1）不能从hash表中删除数据。 对策：把使用过的槽标记为无效，才能执行删除。若查找时遇到无效的槽，则应继续执行查找。 2）当表被填满时性能下降明显； 非线性再散列法di 为非线性的比如，di = 以固定的数作为种子所生成的随机数序列。可以避免相似数据项的聚集。 负载因子：hash表中的数据项个数除以有效槽的总数。 再散列法总结：再散列法包括线性再散列和非线性再散列 优点：容易进行动态编码； &emsp;负载因子较低并且不太可能执行删除操作的情况下，它的速度足够快。通常认为，负载因子大于0.5时，再散列将不是一种切实可行的解决方案。 适用场景： &emsp;只应该在快速而又随性的情况下，或者在快速原型化的环境中使用再散列法解决冲突。若不满足上述需求，则应该使用外部拉链法。 外部拉链法将散列表看做一个链表数组。Hash表中的每个槽要么为空，要么指向一个链表。 可以通过将数据项添加到链表中的方法来解决冲突：将所有hashkey相同的数据项存储在同一链表中。（“聚集”的效果） 解决冲突的代价：不会超过向链表中添加一个结点，无需执行再散列。 与前面的2种再散列法不同的是，外部拉链法可以容纳的元素只取决于可用的内存大小；而再散列法中hash表的最大表项取决于表的大小。 总结： 优点：平均查找时间=链表长度/2+1（链表非空时）； 缺点：需要多一些的存储空间，因为每次探查时都需要添加结点，而不仅仅是数据项。但是，在硬件便宜的现在，可以忽略不计，故该方法现在用得最多。 例子1：给定关键字集合{19,01,23,14,55,68,11,82,36} 假设H(key)=key mod 11（表长=11）， 要求：依据不同的冲突解决方法，分别构造出Hash表 1）采用线性再散列法解决冲突: 1di=1,2,3,4... 首先，哈希表表长是11，因此有0-10个哈希槽，上图表格上方是槽号，下方是查找成功该元素的探测次数。填入过程如下: 第一个key 19，它的地址是H(19)=19 mod 11=8，因此放到散列表的数组下标为8的位置，无冲突，直接填入。即查找成功时，探测1次。 第二个key 01，它的地址是H(01)=01 mod 11=1，因此放到散列表的数组下标为1的位置，无冲突，直接填入。即查找成功时，探测1次。 第三个key 23，它的地址是H(23)=23 mod 11=1，因此放到散列表的数组下标为1的位置，冲突，根据线性探测再散列法来处理这个冲突，探测下一个位置2，无冲突，填入，因此访问23成功的探测次数是2。 第四个key 14，它的地址是H(14)=14 mod 11=3，因此放到散列表的数组下标为3的位置，无冲突，直接填入。即查找成功时，探测1次。 第五个key 55，它的地址是H(55)=55 mod 11=0，无冲突，直接填入。即查找成功时，探测1次。 第六个key 68，它的地址是H(68)=68 mod 11=2，此时2位置已经有元素23，产生冲突，我们根据线性探测再散列法来处理这个冲突，探测下一个位置3,冲突，继续探测位置4，此时没有冲突，将68填入位置4，因此查找68成功的探测次数是3次。 第七个key 11，它的地址是H(11)=11 mod 11=0，此时2位置已经有元素55，产生冲突，我们根据线性探测再散列法来处理这个冲突，多次探测，到位置5时，才有空位置填入11，因此查找成功11的探测了0、1、2、3、4、5，一共6次。 第八个key 82，它的地址是H(82)=82 mod 11=5，冲突，探测下一位，位置6为空，填入元素82，因此查找82成功的探测次数是3次。 第九个key 36，它的地址是H(36)=36 mod 11=3，位置3产生冲突，继续探测4,5,6,7，填入位置7。查找成功36共探测了5次。 接下来愉快的计算ASL了~~~~ 再看一下填好的哈希表： 计算平均查找长度（ASL）： 查找成功时的平均查找长度（查找概率相等）： 查找成功的时候看的是元素，元素查找的长度也就等于需要探测的次数，根据上面的计算，元素55查找长度是1，元素01查找成功长度是1，元素23查找成功长度是2，依次类推。也就是上面表格下记录的数字。 因此 ASL=(1·4+2·2+3·1+5·1+6·1)/9=22/9 （除数是元素个数） 查找不成功时候的平均查找长度： 查找不成功，也就是元素不在哈希表中，根据哈希函数，任何一个数经计算以后的初始地址只可能在0~10的位置 此时看位置，查找0~10位置查找失败的查找次数为： 位置0，到第一个关键字为空的位置9需要比较10次，因此查找不成功的次数为10. 位置1，到第一个关键字为空的位置9需要比较9次，因此查找不成功的次数为. 以此类推，位置0-8查找不成功的次数分别是10、9、8….4、3、2 位置9和10本身就是空的，查找不成功的次数都是1，因此 ASL=(10+9+8+7+6+5+4+3+2+1·2)/11=56/11 （除数是位置的个数） 2）采用非线性再散列法解决冲突，假设 1di=1^2,-1^2,2^2,-2^2,3^2,-3^2,... (此处我有点疑惑，找11的H(11)=0,冲突后位置是加3的平方，11应该放在数组下标为9的位置才对吧？) 例子2：给定关键字集合{19,01,23,14,55,68,11,82,36}假设H(key)=key mod 7（表长=7）， 要求：采用外部拉链法解决冲突，并构造出Hash表 （要会画图表示，注意这里是头插法) 计算平均查找长度（ASL）： 查找成功时的平均查找长度（查找概率相等）： 看元素，蓝色框起来的，定位到槽，是第一个元素，查找长度是1，红色框起来的先访问到前一个元素（前面蓝色的）再访问到该元素，因此查找长度是2，以此类推，黄色框起来的元素查找成功长度是3. ASL=(1·6+2·2+3·1)/9=13/9 查找不成功时候的平均查找长度： 查找不成功，就看每个槽位，访问不到元素时的访问次数，比如0位置，1个元素，查找失败长度就是2，同理，1位置，查找失败长度3,本身就是空的链表的位置，比如位置3，查找失败长度就是1，以此类推。 ASL=(2+3+2+1+2+4+2)/7=16/7 哈希表的查找及性能分析如何查找： 采用平均查找长度ASL (Avarage Search Length)来衡量Hash表的性能。 这部分的例子见上一小节的例子。（重点） 参考资料【1】中科大余艳玮老师实用算法课程 【2】[程序员实用算法].Andrew.Binstock.等著","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"实用算法总结(二) 栈和队列","slug":"实用算法总结(二) 栈和队列","date":"2019-01-02T13:30:29.000Z","updated":"2019-01-03T06:00:12.676Z","comments":true,"path":"2019/01/02/实用算法总结(二) 栈和队列/","link":"","permalink":"http://yoursite.com/2019/01/02/实用算法总结(二) 栈和队列/","excerpt":"","text":"栈线性表：有限个数据元素组成的序列，记作(a1,a2, … , an) 栈：操作受限的特殊线性表，即限定在表尾进行插入或删除操作的线性表； 栈顶(top)：允许插入或删除的一端——表尾端； 栈底（base/bottom）——表头端 特性：后进先出 存储结构： &emsp;顺序栈：顺序方式存储 &emsp;链栈：链式存储 栈的应用举例：函数调用； 顺序栈的定义与实现顺序栈：利用顺序表来实现栈 C语言定义： 12345678struct stack_struct &#123; ElemType *base; /* point to base of stack */ int stack_size; /* number of elements */ int min_stack; /* bottom-most element */ int max_stack; /* last possible element */ int top; /* current top */&#125;;typedef struct stack_struct Stack; 原子操作的实现：Stack *this_stack; 创建空栈（初始化栈） &emsp;将this_stack-&gt;base指向分配成功的连续内存空间的开始处; &emsp;this_stack-&gt;top=-1（注意不是0,若为0则意味着栈中已有一个元素了）; 销毁已有栈 123//关键操作this_stack-&gt;top=-1;free(this_stack-&gt;base); 查找直接后继和直接前驱 &emsp;若要查看的元素下标是合法的（[0,top]），则可以通过this_stack-&gt;base的下标来随机存取与栈顶元素间隔为i的栈元素 ： 1( this_stack-&gt;base )[this_stack-&gt;top – i]. 入栈 &emsp;若栈未满，则让栈顶下标top递增，然后将要入栈的数复制到栈顶处。 &emsp;分析：插入位置为栈顶元素的下一个，无须判断位置的合法性；上溢即栈满的条件需要判断，由于是增量式分配，故栈满时需要重新申请空间. 出栈 &emsp;若栈未空，则将栈顶元素复制到一个指定的目的地；并让栈顶下标top递减以指向栈上的下一个元素：1this_stack-&gt;top -= 1 入栈和出栈的时间复杂度都是O(1) 关键问题：怎么判断栈满、栈空？ 栈空: stack-&gt;top==-1 栈满：stack-&gt;top == this_stack-&gt;max_stack 链栈的定义与实现链栈：用链表来实现栈 栈顶(top)：用链表的头指针来表示。 栈底(base)：无需额外表示。(只在栈顶top中进行操作) 特点：无栈满问题，内存可以扩充，除非是内存不足。 链栈的原子操作课件中没有涉及，个人觉得也应该掌握，参考了一下博客：数据结构 第6讲 链栈，总结如下： 定义链栈 12345typedef struct Snode&#123; ElemType data; struct Snode *next;&#125;Snode,*LinkStack； 初始化链栈 12345bool InitStack(LinkStack &amp;S) //构造一个空栈S&#123; S=NULL; return true;&#125; 入栈 123456789bool Push(LinkStack &amp;S, int e) //在栈顶插入元素e&#123; LinkStack p; p = new Snode; //生成新结点 p-&gt;data = e; //将e放在新结点数据域 p-&gt;next = S; //将新结点的指针域指向S，即将S的地址赋值给新结点的指针域 S = p; //修改栈顶指针为p return true;&#125; 出栈 123456789101112bool Pop(LinkStack &amp;S, int &amp;e) //删除S的栈顶元素，用e保存其值&#123; LinkStack p; if (S == NULL) //栈空 return false; e = S-&gt;data; //将栈顶元素赋给e p = S; //用p保存栈顶元素地址，以备释放 S = S-&gt;next; //修改栈顶指针，指向下一个结点 delete p; //释放原栈顶元素的空间 return true;&#125; 取栈顶元素 123456int GetTop(LinkStack S) //返回S的栈顶元素，不修改栈顶指针&#123; if (S != NULL) //栈非空 return S-&gt;data; //返回栈顶元素的值，栈顶指针不变 else return -1;&#125; 问题： 1.需要引入头结点（无需） 2.在链栈下的入栈、出栈如何实现？(见上面) 3.如何判断栈空？（头指针为空即栈空） 4.顺序栈中为何要定义base（个人觉得是用来检查内存分配是否成功，以及访问栈中的元素也要借助base) 两种栈的总结对比推荐使用顺序栈，实现简单 栈的受限操作的特性正好屏蔽了顺序表的弱势：添加和删除数据都是在同一端进行的。 栈的应用:递归这里知识其实挺多的，在此简单总结一下： 递归的实现： 调用前： &emsp;现场保护（参数、返回地址、旧基址），被调用函数的局部变量的空间分配，控制转移至被调用的函数入口。 调用后： &emsp;保存计算结果，释放被调函数的数据区，控制转移回调用处。 实现——栈 “后调用先返回”。系统利用递归工作栈记录各层调用的现场信息。 补充：C中进程的虚拟内存分配 1、栈区（stack）： &emsp;由编译器自动分配和释放，存放函数的参数值、局部变量的值等，甚至函数的调用过程都是用栈来完成。其操作方式类似于数据结构中的栈。 2、堆区（heap）： &emsp;一般由程序员手动申请以及释放，若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。 3、全局区（静态区）（static）： &emsp;全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放空间。 4、文字常量区： &emsp;常量字符串就是放在这里的。程序结束后由系统释放空间。 5、程序代码区：存放函数体的二进制代码。 总结：什么时候可以使用栈？ 程序员需要跟踪程序当前所在的位置 程序员需要知道什么动作或数据位于当前正在进行的动作之前 队列队列：是操作受限的特殊线性表。限定在一端进行插入，而在另一端进行删除。 队头(front)：允许删除的一端； 队尾(rear)：允许插入的一端 特性：先进先出 存储结构： 循环队列：顺序存储 链队列：链式存储 队列的应用举例：操作系统的作业排队； 顺序队列定义：利用顺序表来实现队列。约定front指向队列头元素，rear 指向队尾元素的下一位置。 C语言定义：1234567#define MAXQSIZE 100 /* 最大队列长度 */typedef struct&#123;ElemType *base; /* 存储空间 */int front; /* 头指针，指向队列的头元素 */int rear; /* 尾指针，指向队尾元素的下一个位置 */&#125; queue_struct; /* 非增量式的空间分配 */ typedef struct SqQueue; 原子操作：SqQueue Q; 创建空队列 &emsp;将this_stack-&gt;base指向分配成功的连续内存空间的开始处; Q.front=Q.rear=0; 入队 &emsp;若队列未满， Q.rear位置放新插入的元素，Q.rear++（可避免大量移动） （分析：插入位置为Q.rear，无须判断位置的合法性；上溢即队列满的条件需要判断，由于是增量式分配，故队列满时需要重新申请空间）; 出队 &emsp;若队列未空，则Q.front位置为待删除的元素，Q.front++（可避免大量移动） 问题： 1）如何判定队空？如何判定队满？ 队空条件：Q.front == Q.rear 队满条件：Q.rear == MAXQSIZE 2）为何要使用循环队列，而不用普通的顺序式队列？ 存在假上溢(由于出队操作，队列空间的上部可能存在空闲空间) 循环队列解决假上溢的方法：将队列假想为首尾相接的环，即循环队列。 入队：Q.rear = ( Q.rear+1)%MAXQSIZE 出队：Q.front = ( Q.front+1)%MAXQSIZE 队空条件：Q.front == Q.rear，由于出队Q.front追上了Q.rear 队满条件：Q.front == Q.rear，由于入队Q.rear追上了Q.front 问题：队空和队满的判断条件一样 如何区分队空和队满？ 方案1：设标志位：不足在于需要额外对标志位的判断及维护 方案2：在队列的结构中引入长度成员，在初始化队列、入队、出队操作中维护这个成员。 方案3：少用一个元素空间，即队满的条件为：(Q.rear+1)% MAXQSIZE == Q.front 链队列链队列：用双向链表来实现队列。 队头(front)：用链表的头指针来表示 队尾(rear)：用链表的尾指针来表示 特点：无队列满问题：内存可扩充（除非是内存不足）； 问题： 1）是否需引入头结点？（需要。特殊：对于空队列的入队） 空队列时候，队头front和队尾rear都指向头结点。 2）在链队列下的队列初始化、入队、出队算法如何实现？ （略,后续有时间再补充） 3）如何判断队空？ Q.front==Q.rear 队列的总结循环队列：（难）需额外区分队空和队满 链队列：（推荐）（直接利用带头结点的双向链表来实现） 参考资料【1】中科大余艳玮老师实用算法课程 【2】[程序员实用算法].Andrew.Binstock.等著 【3】数据结构 第6讲 链栈","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://yoursite.com/tags/栈和队列/"}]},{"title":"机器学习总结（一）基本概念","slug":"机器学习总结（一）基本概念","date":"2019-01-01T13:39:26.000Z","updated":"2019-01-15T07:08:54.721Z","comments":true,"path":"2019/01/01/机器学习总结（一）基本概念/","link":"","permalink":"http://yoursite.com/2019/01/01/机器学习总结（一）基本概念/","excerpt":"","text":"机器学习的历史（略） 什么是机器学习对于给定的任务T，在合理的性能度量方案P的前提下，某计算机程序可以自主学习任务T的经验E，随着提供合适、优质、大量的经验E，该程序对于任务T的性能逐步提高。 所谓机器学习更通俗的说就是：我们使用计算机设计一个系统，使它能够根据提供的训练数据按照一定的方式来学习，随着训练次数的增加，该系统可以在性能上不断学习和改进，通过参数优化的学习模型，能够用于预测相关问题的输出。 基本概念有监督学习(Supervised Learning)：&emsp;根据已有的训练样本，通过不断计算，从样本中学习选择特征参数，对模型建立目标函数，从而对未知样本进行预测。 &emsp;优点：可以有效利用先验数据对后验数据进行预测 &emsp;缺点：训练数据人为收集，具有一定的主观性，预测结果只可能是训练数据中的类别，不会产生出新的类别。&emsp;如神经网络、SVM、决策树等。 无监督学习(Unsupervised Learning)：&emsp;对模型不事先进行先验知识学习，不对模型进行训练，使用未分类的样本数据直接进行分类的过程。 &emsp;优点：人为干预较少，结果具有一定的客观性。 &emsp;缺点：计算过程较为复杂。如聚类算法等。 输入与输出空间&emsp;输入与输出所有可能取值的集合分别称为输入空间X和输出空间Y。输入空间和输出空间可以是有限集合，也可以是整个欧氏空间； &emsp;输入与输出空间可以是同一空间，也可以是不同空间。但通常输出空间远小于输入空间。 训练集(training set)&emsp;从数据中学习得到模型的过程称为“学习”或“训练”，训练过程中使用的数据称为“训练样本”。训练样本由输入和输出对组成，所有的训练样本对构成了训练集，表示为：&emsp;T={(x1,y1),(x2,y2),…,(xm,ym)} 假设空间Н(hypothesis space)&emsp;学习的目的就是要找到一个由输入到输出映射（假设）最好的模型，由输入空间到输出空间所有映射的集合称为假设空间。 &emsp;即：我们可以把学习过程看作为一个在所有假设组成的空间中进行搜索的过程，搜索目标是找到与训练集匹配的假设。 奥卡姆剃刀(Occam’s razor)原则&emsp;奥卡姆剃刀原则是自然科学研究中一种常用和最基本的原则，即“若有多个假设与观察一致，则选用最简单的那个”。 回归(regression)和分类(classification)&emsp;回归和分类是对不同预测任务的相应称法。 &emsp;若我们要预测（输出）的结果是连续值，则此类学习任务称为回归； &emsp;若我们要预测（输出）的结果是离散值，则此类学习任务称为分类。 &emsp;若问题输出结果只有二个类别，则通常称为二分类问题，否则为多分类问题。 &emsp;回归包含线性回归和逻辑回归，线性回归等同于函数拟合，用于模型学习和连续值输出；逻辑回归可解决分类问题，输出离散值。 常用评价指标错误率E&emsp;输出错误的样本数占样本总数的比例 &emsp;E=α/m &emsp;其中α为错分数，m为样本总数 正确率或称准确率&emsp;Acc=1-E 误差(error)&emsp;模型预测输出与样本真实输出之间的差异称为误差 经验(训练)误差&emsp;模型在训练集上的误差称为经验或训练误差。 泛化误差(generalization error)&emsp;模型在新样本上的误差称为泛化误差。所谓泛化是指从特殊到一般的过程，即从具体事实归纳出一般规律的过程。 方差和均方差&emsp;方差又称均方误差是误差分析中比较常用的一种指标，其定义为： &emsp;在预测任务中，对于给定的数据集T={(x1,y1),(x2,y2),…,(xm,ym)}，f(x)为模型预测输出，y为样本真实输出，则二者之间的方差为： &emsp;对于连续域的情况： &emsp;其中p(x)为概率密度函数 &emsp;均方差(标准差)： 过拟合(over-fitting)&emsp;过拟合是指学习时选择模型所包含的参数过多，以至于出现模型对已知数据预测的很好，对未知数据预测得很差的现象。和过拟合相对应的现象为欠拟合。 置信度(confidence level)&emsp;置信度也称置信水平是指总体参数值落在样本统计值某一区间的概率，即对事件真实性的相信程度。 置信区间(confidence interval)&emsp;置信区间是指在某个置信水平下，样本统计值与总体参数值间误差的范围。置信区间越大，置信水平就越高。 常用公式和函数欧氏距离(euclidean distance)&emsp;对于平面上的二点P1(x1,y1)，P2(x2,y2)欧氏距离定义为： 曼哈顿距离(街区距离) 闵可夫斯基距离&emsp;对于二个n维的变量A(x1,x2,…,xn)和B(y1,y2,…yn)，闵氏距离为： 海明距离&emsp;在信息论中，二个字符串之间的海明距离是二个字符串对应位置的不同字符数。 &emsp;如：A=(1011101)，B=(1001001) &emsp;海明距离=2 杰卡德(Jaccard)相似度&emsp;J(A,B) = |A∩B| / |A∪B| &emsp;其中A，B为集合 &emsp;如网页相似度比较 文本编号 内容 A 努力建设国家级自然保护区 B 保护自然保护区义不容辞 &emsp;①分词处理： &emsp;A ={‘努力’，‘建设’，‘国家级’，‘自然保护区’｝&emsp;B ={‘保护’，‘自然保护区’，‘义不容辞’｝ &emsp;②计算相似度： &emsp;A∩B = ｛‘自然保护区’｝ &emsp;A∪B ={‘努力’，‘建设’，‘国家级’，‘自然保护区’，‘保护’，‘义不容辞’｝ &emsp;J(A,B) = 1/6 = 0.17 余弦相似度&emsp;对于向量a(x1,y1)和b(x2,y2)的余弦值为： &emsp;对于n维时，若x=(x1,x2,…,xn)，y=(y1,y2,…,yn) &emsp;例：网页文本相似度计算 文本编号 内容 A 数据价值是一种数据艺术 B 算法价值是一种算法艺术 &emsp;① 分词处理： &emsp;A={‘数据’,‘价值’,‘是’,‘一种’,‘数据’,‘艺术’} &emsp;B={‘算法’,‘价值’,‘是’,‘一种’,‘算法’,‘艺术’} &emsp;② 计算并集 &emsp;A∪B={‘数据’,‘价值’,‘是’,‘一种’,‘算法’,‘艺术’} &emsp;③ 词频计算： &emsp;A={数据(2),价值(1),是(1),一种(1),算法(0),艺术(1)} &emsp;B={数据(0),价值(1),是(1),一种(1),算法(2),艺术(1)} &emsp;④ 建立特征向量： &emsp;A=(2,1,1,1,0,1) &emsp;B=(0,1,1,1,2,1) &emsp;⑤ 相似度计算： &emsp;余弦相似度更侧重于方向问题。 先验概率&emsp;事件A发生的概率记为P(A)，这个先验概率值可以用相对频率来近似。根据大数定律，当训练集包含足够多的独立同分布样本时P(A)可通过样本出现的频率来估算。 联合概率&emsp;事件A和事件B同时发生的概率，记为P(A,B)。 &emsp;若事件A和事件B相互独立，则： &emsp;P(A,B) = P(A) ×P(B) 条件概率(后验概率)&emsp;在事件A发生的条件下，事件B发生的概率，记为P(B|A) &emsp; P(B|A) = P(A,B)/P(A) 正态分布(高斯分布)&emsp;连续型随机变量x的概率密度为： 符号函数 指示函数 损失函数&emsp;损失函数也称代价函数，可用于度量模型预测错误的程度，它是一个非负实值函数。 &emsp;令假设空间H中选取模型f作为决策函数，对于给定的输入x，由f(x)得到预测结果(输出)。这个输出值f(x)与真实值y可能一致也可能不一致，那么根据情况可选择一个损失函数来度量预测错误的程度，记为L(y,f(x))。 阶越函数（step function) Sigmoid函数（S型函数） 正则化（regularizayion)&emsp;用一组与原不适定问题相邻近的适定问题的解去逼近原问题的解的方法称为正则化方法。 &emsp;不适定问题：很难求解的问题 &emsp;正则化的目的：防止过拟合 &emsp;正则化的本质：约束(限制)要优化的参数 &emsp;正则化通过添加一些约束，使原问题解空间得到了压缩，简化了模型。 &emsp;正则化公式： &emsp;L1正则： &emsp;L2正则 &emsp;L1+ L2 其中第一项L（θ）是损失函数，第二项为正则化项或者称为惩罚项。 测试集组织&emsp;模型性能好坏一个简单的评价方法可以用模型的错误率来衡量。我们构建的模型不是对已有样例的重新预测或分类，而是要对未来样例的预测或分类，即模型的泛化能力。通常我们可以通过实验测试来评估模型，这就需要一个测试集。 &emsp;测试样例的组织： &emsp;假设已有m个样本D={x1,x2,…,xm}，从D中挑选部分样例组成训练集，再从D中挑选部分样例组成测试集。 &emsp;问题：如何挑选？ 留出法(hold-out)&emsp;将D划分为二个不相交的集合S和T，其中D=S∪T，S∩T=Ф &emsp;如D包含了1000个样例，划分后，S包含700个训练样本，T包含了300个测试样本。如果模型在T上有90个样本预测错误，则错误率为：E=90/300=0.3，错误率为30%。 &emsp;这种方法需注意的： &emsp;① 训练集/测试集的划分尽可能地保持数据分布的一致性，避免因样例划分过程引入额外的偏差。 &emsp;② 存在多种划分组合，每种划分都对应了模型的评估性能，所以单次使用留出法得到的评估结果往往是不够稳定可靠的。改进的方法是采用若干次随机划分取平均值作为留出法的评估结果。 &emsp;③ 划分时如果S较大接近于D时，用S训练出的模型更接近于用D训练出的模型，但此时T较小，评估结果可能不准确；若T较大时，用S训练出的模型与用D训练出的模型有较大的差别，将降低评估结果的真实性。通常划分的比例为2/3～4/5的样例作为训练集，其余作为测试集。 交叉验证法(cross validation)**&emsp;将样本数据集D划分为k个大小相似的互斥子集，即D=D1∪D2∪…∪Dk，其中：Di∩Dj=Ф (i≠j) &emsp;划分时同留出法尽量保持每个子集数据一致性，然后每次用k-1个子集的并集作为训练集，剩余的一个子集作为测试集，这样共获得k组训练/测试集，相应地可进行k次训练和测试。用k次测试结果的平均值作为模型的性能评估值。 自助法(bootstrapping)&emsp;每次从D中随机挑选一个样例拷贝到D’中且该样例仍保留在D中，下次挑选时仍可能被选中。重复从D中挑选m个样例到D’中，此时D’中可能某个样例出现多次，而D中某些样例可能不在D’中。 &emsp;估算样例在m次挑选中未被选中的概率为: 参考资料【1】中科大张曙老师机器学习课程 【2】 统计学习方法","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"实用算法总结(一) 基本概念、线性表","slug":"实用算法总结(一) 基本概念、线性表","date":"2019-01-01T13:03:29.000Z","updated":"2019-01-02T13:30:18.516Z","comments":true,"path":"2019/01/01/实用算法总结(一) 基本概念、线性表/","link":"","permalink":"http://yoursite.com/2019/01/01/实用算法总结(一) 基本概念、线性表/","excerpt":"","text":"基本概念&emsp;算法的特征：有穷性、确定性、可行性、输入、输出 &emsp;程序=算法+数据结构 典型问题： 800电话号码有如下的格式：800-8222657，其中有效的800免费电话不超过800万个，比如不存在以0或1开头的有效免费电话。现要求对这些800免费电话号码进行排序，要求内存不超过1MB。 &emsp;解题思路：位图法 &emsp; 每个7位的十进制整数表示一个小于1000万的整数，我们使用一个具有1000万个位的字符串来表示这个文件，其中，当且仅当整数i在文件中存在时，第i位为1。 &emsp;若给定表示文件中整数集合的位图数据结构，则可以分为三个自然阶段来编写程序。 &emsp;第一阶段将所有位都置为0，从而将集合初始化为空。 &emsp;第二阶段通过读入文件中的每个整数来建立集合，将每个对应位置为1。 &emsp;第三阶段检验每一位，如果该位为1，则输出对应的整数，由此产生有序的输出文件。 &emsp;令n为位向量中的位数（在本例子中为100000000），程序可以用如下伪代码表示如下： 12345678910/* phase 1:initialize set to empty */ for i =[0,n) bit[i]=0/* phase 2:insert present elements into the set */ for each i in the input file bit[i]=1/* phase 3:write sorted output */ for i =[0,n) if bit[i]==1 write i on the output file 从2.5亿个整数中找出不重复的数字的个数。可用的内存限定为600M；要求算法尽量高效，最优。 从1亿个整数中找出最大的1万个。 评估算法： 基本要求：正确性、可读性、健壮性（有异常处理机制） 更实用的要求：（性能） 高效率（时间复杂度低） 低存储量（内存开销小） 线性表数据结构数据结构包括逻辑结构和存储结构/物理结构 逻辑结构从逻辑关系上对数据结构进行描述 是从具体问题抽象出来的数据模型 与数据本身的存储（数据元素的存储位置、类型和具体取值）无关。 如： 线性结构：线性表； 非线性结构：树、图； 四类数据结构： 集合结构 &emsp;&emsp;元素间无任何关系，即关系结合是空集：S={} 线性结构 元素之间的关系是1:1 除了头结点外，所有结点有且仅有一个直接前驱。 除了尾结点外，所有结点有且仅有一个直接后继。 树形结构： 如，一般树、二叉树、森林 一个结点可有多个直接后继（除了叶子结点外） 但只有一个直接前驱（除了根节点外） 图形结构 元素之间的关系是m:n 一个结点可以有多个直接后继，也有多个直接前驱。 存储结构/物理结构数据结构在计算机中的表示（或映像） &emsp;顺序映像：顺序存储结构 &emsp;非顺序映像：链式存储结构 &emsp;如，线性表有顺序表和链表两种物理存储方式 它可以借助于具体某程序语言中的“数据类型”来定义它。也可采用typedef将类型名重命名，以增加代码的可读性。 12345678910//顺序表数据存储结构的实现int Sqlist[100]; //单链表数据存储结构的实现struct Node&#123; int data; struct Node *next&#125;;Typedef struct Node *Link;Link head; 线性表什么是线性表？ &emsp;有限个数据元素组成的序列，记作(a1,a2, … , an) 逻辑特征：线性特征 存储结构：顺序表和链表两种方式 基本操作: &emsp; 创建空的线性表 &emsp; 销毁已有线性表 &emsp; 查找直接后继和直接前驱 &emsp;插入一个元素 &emsp; 删除一个元素 顺序表的定义与实现顺序表:在内存中连续存储的线性表 特性： 逻辑上相邻的元素，物理存储地址必相邻 ； 可随机存取：通过顺序表的名称和下标可以直接访问顺序表中的任一个元素。 静态定义：利用数组 方案一： 1int Sqlist[100]; 方案二： 12#define List_Size 100 /*分配空间的大小*/int Sqlist[List_Size ]; 方案三：（通用性最强，类似STL:vector） 123456#define List_Size 100/*分配空间的大小*/Typedef Struct&#123;int elem[List_Size ]; /*存储空间*/int len; /*实际长度*/&#125;SqList_static;/*“顺序表”数据存储结构的实现；描述了List_Size个int型变量组成的集合，且隐含着可利用下标[]来描述两个int型变量间的联系.*/ 评价: &emsp;该结构比较机械分配的内存空间大小固定。 &emsp;List_Size 过小，会导致顺序表上溢； &emsp;List_Size过大，会导致空间利用率不高 &emsp;在编译的时候，系统在函数栈中分配连续的内存空间。当静态顺序表所在的函数执行完毕后，由系统来回收所开辟的内存空间。 &emsp;程序运行时，出现上溢问题，将没法修补。 动态定义：利用指针123456#define List_Size 100 /*分配空间的大小*/typedef struct&#123; int *elem; /*顺序表的存储空间*/ int len; /*实际长度*/ int ListSize ; /*当前分配的空间大小*/ &#125; Sqlist; 特点： 需手动分配存储空间:malloc() 可以在程序运行过程中，重新分配空间：realloc() 不再使用顺序表时，需手动释放所占的空间：free() 可以避免“机械”，但是会增加时间开销。 C语言中的动态分配与释放函数： 123456Void *malloc(unsigned int size)/*生成一个大小为size的结点空间，将该空间的起始地址赋给p*/Free(void *p)/*回收p所指向的结点空间*/Void *realloc(void *p, unsigned int size)/*重新分配大小为size的结点空间，并将该空间的起始地址赋给p */ 构造一个空的顺序表： 123456789Int InitSqList(SqList *L)//构造一个空的顺序表L&#123; L-&gt;elem=(int *) malloc(List_Size *sizeof(int)); if (L-&gt;elem==NULL) exit(EXIT_FAILURE); L-&gt;len=0; L-&gt;ListSize =List_Size; return 1;&#125; 两种定义的对比总结： 不同：分配存储空间的方式不同 静态定义的顺序表由系统自动分配和回收存储空间； 动态定义的顺序表需要手动分配和回收存储空间，但是也可以再分配。 因而它们创建和销毁顺序表两种操作的实现不同， 相同点： &emsp;本质上都是存储在连续空间上，因而对数据的操作方式（查找，插、删）都是一样的。 顺序表：插入操作的实现 参数： 顺序表&amp;L、插入位置i、插入元素e 插入分析： 第i个位置放e，则原来第i~L.len个数据元素必须先后移，以腾出第i个位置; 后移的顺序为：从最后一个元素开始，逐个往后移 算法流程图： 代码：12345678910111213141516171819Status ListInsert_Sq( SqList &amp;L, int i, ElemType e) &#123; // 位置合法性的判断，合法的位置：i:1..L.len+1 if ( i&lt;1 || i&gt;L.len +1 ) return 0; // 上溢时，要先申请一个有一定增量的空间：申请成功则原空间的元素复制到新空间，修改L.listsize，再进行插入工作；否则报错退出。 if( L.len &gt;= L.listsize) &#123; newbase = (ElemType *) realloc(L.elem,(L.listsize+ LISTINCREMENT)*sizeof(ElemType)); if ( newbase == NULL ) exit(OVERFLOW); L.elem = newbase; L.listsize += LISTINCREMENT; &#125; // 插入元素 for ( j = L.len; j &gt;= i; j--) L.elem[j] = L.elem[j-1]; L.elem[i-1] = e; L.len++; return 1;&#125; 时间复杂度分析： &emsp;最好：插入位置为n+1,时间复杂度O（1） &emsp;最坏：插入位置为1，时间复杂度O(n） &emsp;平均：O(n） 顺序表：删除操作的实现 参数： &emsp;顺序表&amp;L、删除位置i 删除分析： &emsp;去掉第i个元素，则原来第i+1~L.len个数据元素须前移，以覆盖第i个位置; 算法流程图： &emsp;代码： 123456789Status ListDelete_Sq( SqList &amp;L, int i) &#123; // 位置合法性的判断 if ( i&lt;1 || i&gt;L.len ) return 0; // 删除 for ( j = i; j &lt; L.len ; j++) L.elem[j-1] = L.elem[j]; L.len--; return 1;&#125; 时间复杂度分析： &emsp;最好：删除位置为n,此时无须移动元素，时间复杂度为O(1); &emsp;最坏：删除位置i为1，此时无须移动元素，时间复杂度为O(1) &emsp;平均：O(n） 顺序表优缺点： 优点：随机存取。 弱点： 空间利用率不高（预先按最大空间分配） 表的容量不可扩充（针对顺序表的静态定义方案） 即使表的容量可扩充（针对顺序表的动态定义方案），由于其空间再分配和复制的开销，因而也不允许它频繁地使用 插入或删除时需移动大量元素。 适用环境例1：顺序文件的查找。（有序顺序表+二分查找） 例2：顺序文件的查找，并在文件中添加一个元素。（基于二叉平衡树的查找） 结论：顺序表适用于输入数据的大小已知，且无太多动态操作的应用问题。 链表的定义与实现 链表由一连串结点组成。 结点： 是链表元素的存储映像。 每个结点包括数据域和指针域。 指针：即链，它用于将结点们联系起来。也可以用于唯一定位一个结点。 头指针：链表存取的开始。 单链表：只有一个指针域的链表。 双链表：有两个指针域的链表。 结论：链表中用链来表明线性特征。 定义123456struct Node&#123; int data; struct Node *next&#125;;&#125;;Typedef struct Node *Link; Link head; 无头结点的单链表 &emsp;头指针为L，则空表时，L == NULL &emsp;由于第一个结点无前驱结点，所以只能通过某指针变量来指向，如L； &emsp;其余结点均有前驱结点，故可通过其直接前驱结点的next域来指向，即……-&gt;next；表示方法的不同，会造成对结点的操作处理的不同 有头结点的单链表 &emsp;空表时，L指向一结点(称为头结点)，该结点的数据域可以不存储信息，也可存储如表长等的附加信息，结点的指针域存放NULL，即L-&gt;next == NULL。 &emsp;第一个结点和其余结点均可统一表示为其直接前驱结点的next域所指向的结点，即……-&gt;next。 插入操作ListInsert_L(LinkList &amp;L, int i, ElemType e) 【设计思路】 相关结点：ai-1和ai 结点的表示：引入指针变量LinkList p; 关键步骤： ①找到ai-1 的位置，即使p指向ai-1 结点 若p≠NULL，则 ② s = (LinkList)malloc(sizeof(LNode)) ③ s-&gt;data = e ④ s-&gt;next = p-&gt;next ⑤ p-&gt;next = s 注意：④和⑤不能交换，否则会导致ai的位置无法获取。 时间复杂度分析：频度最高的操作：确定ai-1 的位置 若线性表长度为n，则： 最好情况：T(n)=O(1) 最坏情况：T(n)=O(n) 平均情况：T(n)=O(n) 代码： 有头结点的单链表中的插入算法： 12345678910111213141516171819202122 // 有头结点，无须对i为1的插入位置作特殊处理Status ListInsert(LinkList &amp;L, int i, ElemType e)&#123; // 对p,j初始化; *p为L的第j个结点 p = L; j = 0; // 寻找第i-1个结点的位置 while( p != NULL &amp;&amp; j&lt;i-1) &#123; p = p-&gt;next; j++; &#125; // i小于1或大于表长的异常处理 if( p == NULL || j&gt;i-1) return ERROR; s = (LinkList )malloc(sizeof(LNode)); // 生成新结点 if ( s == NULL ) exit(OVERFLOW);// 空间分配不成功，报错返回 s-&gt;data = e; s-&gt;next = p-&gt;next;// 插入L中 p-&gt;next = s; return OK; &#125; 无头结点的单链表中的插入算法 12345678910111213141516171819202122232425262728293031Status ListInsert(LinkList &amp;L, int i, ElemType e) &#123; // 无头结点，须对i为1的插入位置作特殊处理 if ( i==1) &#123; s = (LinkList )malloc(sizeof(LNode)); // 生成新结点 if ( s == NULL ) exit(OVERFLOW); // 空间分配不成功，报错返回 s-&gt;data = e; s-&gt;next = L; // 插入到链表L中 L = s; // 修改链头指针L &#125; else &#123; p = L; j = 1; // 对p,j初始化; *p为链表的第j个结点 while( p != NULL &amp;&amp; j&lt;i-1) &#123; p = p-&gt;next; j++; // 寻找第i-1个结点的位置 &#125; if( p == NULL || j&gt;i-1) return ERROR;// i小于1或大于表长 s = (LinkList )malloc(sizeof(LNode)); // 生成新结点*s if ( s == NULL ) exit(OVERFLOW); // 空间分配不成功，报错返回 s-&gt;data = e; s-&gt;next = p-&gt;next; // 插入到链表L中 p-&gt;next = s; &#125; return OK; &#125; 删除操作【设计思路】 相关结点：ai-1、ai和ai+1 结点表示：p, (p-&gt;next),*(p-&gt;next-&gt;next) 关键步骤： ①找到ai-1 的位置，即使p指向ai-1 结点p-&gt;next≠NULL（有待删除的结点），则 ② q = p-&gt;next (记录待释放结点的位置) ③ p-&gt;next = p-&gt;next-&gt;next ④ free(q) 注意：必须在③④前增加②步，否则在执行了③后要释放的结点无法标识。 创建操作 头插法 &emsp;每次将待插结点*s插入到第一个结点之前；当有头结点时，待插结点也可视为插入到第0个结点(头结点)之后。 &emsp;有头结点的插入步骤： &emsp;① s = (LinkList)malloc(sizeof(LNode)) &emsp;② scanf(&amp;s-&gt;data) &emsp;③ s-&gt;next = L-&gt;next &emsp;④ L-&gt;next = s &emsp;算法时间复杂度分析： &emsp;每次插入一个结点所需的时间为O(1)，因此头插法创建单链表的时间复杂度 T(n) = O(n) 尾插法： &emsp;待插结点*s插入到最后一个结点之后 插入步骤： &emsp;① 获得最后一个结点的位置,使p指向该结点 &emsp;② p-&gt;next = (LinkList)malloc( sizeof(LNode)) &emsp;③ p = p-&gt;next &emsp;④ scanf( &amp;p-&gt;data ) &emsp;⑤ p-&gt;next = NULL 算法时间复杂度分析： &emsp;要想获取最后一个结点的位置，必须从链头指针开始顺着next链搜索链表的全部结点，该过程的时间复杂度是O(n)。如果每次插入都按此方法获取最后一个结点的位置，则整个创建算法的时间复杂度为T(n) = O(n2)。 循环链表问题一：如何从一个结点出发，访问到链表中的全部结点 循环链表 循环链表与单链表的差异： 类型定义不变； 最后一个结点的指针不为空，而是指向表头结点（头结点/第一个结点）； 搜索表时，结束条件不再是看其是否为NULL，而是看其是否等于头指针 问题二：对于循环链表，如何在O(1)时间内由链表指针访问到第一个结点和最后一个结点 头指针表示法： 第一个结点：*(la-&gt;next)&emsp;&emsp; T(n)=O(1) 最后一个结点：需从表头搜索到表尾 &emsp;T(n)=O(n) 尾指针表示法： 第一个结点：*(ra-&gt;next-&gt;next)&emsp; T(n)=O(1) 最后一个结点：*ra &emsp; T(n)=O(1) 双向链表单链表的缺点：只知其直接后继结点，不知当前结点的直接前驱。 巧妙的解决方案：双向链表 &emsp;1）Link prev; curr=prev-&gt;next; &emsp;2）Link prev; curr = prev （处理链表的一个子集时很方便） 每个结点有2个链：分别指向逻辑相邻的2个结点。可在O(1)时间内找到一个结点的直接前驱结点和直接后继结点广泛应用，如STL:list 特点：若d指向表中的一个内部结点，则d-&gt;next-&gt;prior == d-&gt;prior-&gt;next == d 定义： 12345678910Struct Node&#123;ElemType data;struct Node *prior;struct Node *next;&#125;;typedef struct Node * Link;typedef struct &#123;Link head, tail;int len;&#125;DLinkList; 线性表的应用例1：将两个线性表合并为一个线性表； 例2：将按值非递减有序的两个线性表合并为一个有序线性表 ； 参考资料：【1】中科大余艳玮老师实用算法课程 【2】[程序员实用算法].Andrew.Binstock.等著 【3】《编程珠玑(第2版)》","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"线性表","slug":"线性表","permalink":"http://yoursite.com/tags/线性表/"}]},{"title":"排序算法总结","slug":"排序算法总结","date":"2018-12-25T02:04:48.000Z","updated":"2019-01-02T12:06:02.169Z","comments":true,"path":"2018/12/25/排序算法总结/","link":"","permalink":"http://yoursite.com/2018/12/25/排序算法总结/","excerpt":"","text":"本文对排序算法做一次总结和梳理，主要思想+实例+代码实现+时间空间复杂度分析 基于比较的排序算法交换类排序 冒泡排序 基本思想连续的扫描待排序的记录；每趟扫描时，都会移动最大的记录，使之更接近于序列的尾部，像气泡一样缓缓上升。 若某趟扫描过程中没有执行任何交换，则表明记录是有序的，因而需终止排序。 如何移动最大的记录，使之更接近于序列的尾部？ 将当前记录与下一条记录进行比较，若当前记录&gt;下一条记录，则交换两条记录的位置。 实例5 4 3 6 1 从小到大排序 第一趟：从头到尾，两两比较，不符合前小后大，就交换位置。 5和4比较，5比4大，交换位置，接着5和3比较，5比3大，交换位置，5再和6比较，不交换，6和1比较，6比1大，两者交换位置，一趟排序下来，变为 4 3 5 1 6 此时最大的数字6，已经像气泡一样上升到了最后，它的位置就已经确定，下次比较，就只需要对前面4个数字进行排序 第二趟： 4和3比较，交换，4再和5比较，不交换，5和1比较，交换，此趟结束，那么一趟排序下来，变为了 3 4 1 5 6 5也升到了最后，也就是一次排序有一个数字到达了最终位置，第一趟是最后一个数，第二趟是倒数第二个数，因此下次只用对前面的数进行排序。 第三趟： 只用对3 4 1 排序，排序下来变为 3 1 4 5 6 第四趟： 只用对 3 1排序 1 3 4 5 6 第五趟:只有一个1，排序完成 最终就是 1 3 4 5 6 实现代码整个排序过程可以用两层循环完成，代码如下：12345678910111213141516171819void BubbleSort(int *a, int length)&#123; int i,temp,flag; for (i = 0;i &lt; length - 1;i++) &#123; flag=0; for (int j = 0;j &lt; length - i - 1;j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; flag=1; &#125; &#125; if(flag==0) break; &#125;&#125; 快速排序 选择类排序 简单选择排序 堆排序 插入类排序 直接插入排序 折半插入排序 希尔排序 基于某种映射函数的排序算法 桶排序 基数排序","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"scikit-learn学习笔记（一）","slug":"skicit-learn学习笔记(一)","date":"2018-12-23T08:24:49.000Z","updated":"2019-01-02T12:05:37.789Z","comments":true,"path":"2018/12/23/skicit-learn学习笔记(一)/","link":"","permalink":"http://yoursite.com/2018/12/23/skicit-learn学习笔记(一)/","excerpt":"","text":"scikit-learn是一个python的库，包含大量的机器学习算法。由于做kaggle上面的项目需要，使用到了这个库，但是需要注意的是scikit-learn的数据必须是numeric类型的。 安装前提:有python，且安装好了numpy库和scipy库，然后通过pip的方式安装如下： 1pip install -U sickit-learn 选择模型方法官网中有流程图，对于不同的场景需要选择不同的机器学习模型，模型图如下： 图中蓝色的圆圈是判断，绿色的方框是可以选择的算法。 算法分为了四大类： classfication(分类）、regression（回归）、clustering（聚类）、dimensionality reduction（数据降维） 数据集利用 scikit-learn中包含了很多技术集，可供学习。 比如iris数据集，中文名是安德森鸢尾花卉数据集，是一个给鸢尾花做分类的数据集，包含四个属性： 花萼长度、花萼宽度、花瓣长度、花瓣宽度 以及花的品种：山鸢尾、变色鸢尾、维吉尼亚鸢尾 根据四个属性预测出花的品种，是一个典型的分类问题，可以根据这个数据集，走一下sickit-learn的使用流程 使用流程以iris数据集为例子： 导入数据集 查看数据格式 可以看出，每条数据有四个属性，标签一共有三类，用0、1、2表示。 划分数据集 train_test_split可以随机划分数据集，要划分的是iris_X和iris_y，划分比例是训练数据80%,测试数据20% 使用模型、预测、计算准确率 使用knn模型，至于此模型的原理，不是本文重点，不再解释。 打印出的结果可以看到模型预测的结果不一定是完全准确的。可以通过以下方式计算模型的准确率： 训练数据准确率为96%左右，测试数据准确率为93%左右，说明使用knn做鸢尾花数据集的分类是一个不错的选择。 参考：莫烦的学习网站","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]}]}